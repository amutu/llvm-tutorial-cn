<!DOCTYPE HTML>

  <html xmlns="http://www.w3.org/1999/xhtml" lang="zh">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>第二章 实现语法分析器和AST &mdash; LLVM教程</title>
    
    <link rel="stylesheet" href="_static/han.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/rosefinch.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:       '',
        VERSION:        '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX:    '.html',
        HAS_SOURCE:     true
      };
    </script>
    <script type="text/javascript" src="_static/han.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script><link rel="shortcut icon" href="_static/favicon.ico"/><link rel="top" title="LLVM教程" href="index.html" /><link rel="next" title="第三章 LLVM IR代码生成" href="chapter-3.html" /><link rel="prev" title="第一章 教程简介与词法分析器" href="chapter-1.html" /></head>

  <body><div class="navbar navbar-static-top navbar-inverse">
        <div class="navbar-inner">
          <a href="index.html" class="brand">LLVM教程</a>
          <ul class="nav"><li><a href="chapter-3.html">下一页</a></li><li><a href="chapter-1.html">上一页</a></li></ul></div>
      </div><div class="content container-fluid">
        <div class="row-fluid"><div class="document span9"><article >
                <div class="documentwrapper"><div class="body"><div class="section" id="ast">
<span id="chapter-2"></span><h1>第二章 实现语法分析器和AST<a class="headerlink" href="#ast" title="永久链接至标题">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">原文:</th><td class="field-body"><a class="reference external" href="http://llvm.org/docs/tutorial/LangImpl2.html">Implementing a Parser and AST</a></td>
</tr>
</tbody>
</table>
<div class="section" id="id1">
<h2>本章简介<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>欢迎进入“用LLVM开发新语言”教程的第二章。在本章中，我们将以第一章中开发的词法分析器为基础，为Kaleidoscope语言开发一个完整的<a class="reference external" href="http://en.wikipedia.org/wiki/Parsing">语法解析器</a>。搞定语法解析器之后，我们就开始定义并构造<a class="reference external" href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">抽象语法树</a>（AST，Abstract Syntax Tree）。</p>
<p>在解析Kaleidoscope的语法时，我们将综合运用<a class="reference external" href="http://en.wikipedia.org/wiki/Recursive_descent_parser">递归下降解析</a>和<a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser">运算符优先级解析</a>两种技术（后者用于解析二元表达式，前者用于其他部分）。正式开始解析之前，不妨先来看一看解析器的输出：抽象语法树。</p>
</div>
<div class="section" id="id6">
<h2>抽象语法树（AST）<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">抽象语法树的作用在于牢牢抓住程序的脉络，从而方便编译过程的后续环节（如代码生成）对程序进行解读。AST就是开发者为语言量身定制的一套模型，基本上语言中的每种结构都与一种AST对象相对应。Kaleidoscope语言中的语法结构包括表达式、函数原型和函数对象。我们不妨先从表达式入手：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Abstract Syntax Tree (aka Parse Tree)</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// ExprAST - Base class for all expression nodes.</span>
<span class="k">class</span> <span class="nc">ExprAST</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ExprAST</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class="k">class</span> <span class="nc">NumberExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">Val</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">NumberExprAST</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">Val</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="compound-last">上述代码定义了基类<tt class="docutils literal"><span class="pre">ExprAST</span></tt>和一个用于表示数值常量的子类。其中子类<tt class="docutils literal"><span class="pre">NumberExprAST</span></tt>将数值常量的值存放在成员变量中，以备编译器后续查询。</p>
</div>
<div class="compound">
<p class="compound-first">直到目前为止，我们还只搭出了AST的架子，尚未定义任何能够体现AST实用价值的成员方法。例如，只需添加一套虚方法，我们就可以轻松实现代码的格式化打印。以下定义了Kaleidoscope语言最基本的部分所要用到的其他各种表达式的AST节点：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class="k">class</span> <span class="nc">VariableExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">VariableExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// BinaryExprAST - Expression class for a binary operator.</span>
<span class="k">class</span> <span class="nc">BinaryExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">Op</span><span class="p">;</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span><span class="p">,</span> <span class="o">*</span><span class="n">RHS</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">BinaryExprAST</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Op</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">LHS</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">RHS</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// CallExprAST - Expression class for function calls.</span>
<span class="k">class</span> <span class="nc">CallExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Callee</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="n">Args</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">CallExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">callee</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Callee</span><span class="p">(</span><span class="n">callee</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="compound-last">我们（特意）将这几个类设计得简单明了：<tt class="docutils literal"><span class="pre">VariableExprAST</span></tt>用于保存变量名，<tt class="docutils literal"><span class="pre">BinaryExprAST</span></tt>用于保存运算符（如“<tt class="docutils literal"><span class="pre">+</span></tt>”），<tt class="docutils literal"><span class="pre">CallExprAST</span></tt>用于保存函数名和用作参数的表达式列表。这样设计AST有一个优势，那就是我们无须关注语法便可直接抓住语言本身的特性。注意这里还没有涉及到二元运算符的优先级和词法结构等问题。</p>
</div>
<div class="compound">
<p class="compound-first">定义完毕这几种表达式节点，就足以描述Kaleidoscope语言中的几个最基本的结构了。由于我们还没有实现条件控制流程，它还不算图灵完备；后续还会加以完善。接下来，还有两种结构需要描述，即函数的接口和函数本身：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,</span>
<span class="c1">/// which captures its name, and its argument names (thus implicitly the number</span>
<span class="c1">/// of arguments the function takes).</span>
<span class="k">class</span> <span class="nc">PrototypeAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Args</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">PrototypeAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{}</span>

<span class="p">};</span>

<span class="c1">/// FunctionAST - This class represents a function definition itself.</span>
<span class="k">class</span> <span class="nc">FunctionAST</span> <span class="p">{</span>
  <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span><span class="p">;</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Body</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">FunctionAST</span><span class="p">(</span><span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">proto</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">body</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Proto</span><span class="p">(</span><span class="n">proto</span><span class="p">),</span> <span class="n">Body</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="p">{}</span>

<span class="p">};</span>
</pre></div>
</div>
<p class="compound-last">在Kaleidoscope中，函数的类型是由参数的个数决定的。由于所有的值都是双精度浮点数，没有必要保存参数的类型。在更强大、更实用的语言中，<tt class="docutils literal"><span class="pre">ExprAST</span></tt>类多半还会需要一个类型字段。</p>
</div>
<p>有了这些作为基础，我们就可以开始解析Kaleidoscope的表达式和函数体了。</p>
</div>
<div class="section" id="id7">
<h2>语法解析器基础<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">开始构造AST之前，先要准备好用于构造AST的语法解析器。说白了，就是要利用语法解析器把“<tt class="docutils literal"><span class="pre">x+y</span></tt>“这样的输入（由词法分析器返回的三个语元）分解成由下列代码生成的AST：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="n">ExprAST</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VariableExprAST</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="n">ExprAST</span> <span class="o">*</span><span class="n">Y</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VariableExprAST</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">);</span>
<span class="n">ExprAST</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryExprAST</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
</pre></div>
</div>
<p class="compound-middle">为此，我们先定义几个辅助函数：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span>
<span class="c1">/// token the parser is looking at.  getNextToken reads another token from the</span>
<span class="c1">/// lexer and updates CurTok with its results.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">CurTok</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">getNextToken</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">CurTok</span> <span class="o">=</span> <span class="n">gettok</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">这段代码以词法分析器为中心，实现了一个简易的语元缓冲，让我们能够预先读取词法分析器将要返回的下一个语元。在我们的语法解析器中，所有函数都将<tt class="docutils literal"><span class="pre">CurTok</span></tt>视作当前待解析的语元。</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// Error* - These are little helper functions for error handling.</span>
<span class="n">ExprAST</span> <span class="o">*</span><span class="n">Error</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Str</span><span class="p">);</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
<span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ErrorP</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">Error</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ErrorF</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">Error</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">这三个用于报错的辅助函数也很简单，我们的语法解析器将用它们来处理解析过程中发生的错误。这里采用的错误恢复策略并不妥当，对用户也不怎么友好，但对于教程而言也就够用了。示例代码中各个函数的返回值类型各不相同，有了这几个函数，错误处理就简单了：它们的返回值统统是<tt class="docutils literal"><span class="pre">NULL</span></tt>。</p>
</div>
<p>准备好这几个辅助函数之后，我们就开始实现第一条语法规则：数值常量。</p>
</div>
<div class="section" id="id8">
<h2>解析基本表达式<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">之所以先从数值常量下手，是因为它最简单。Kaleidoscope语法中的每一条生成规则（production），都需要一个对应的解析函数。对于数值常量，就是：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// numberexpr ::= number</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseNumberExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NumberExprAST</span><span class="p">(</span><span class="n">NumVal</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// consume the number</span>
  <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">这个函数很简单：调用它的时候，当前待解析语元只能是<tt class="docutils literal"><span class="pre">tok_number</span></tt>。该函数用刚解析出的数值构造出了一个<tt class="docutils literal"><span class="pre">NumberExprAST</span></tt>节点，然后令词法分析器继续读取下一个语元，最后返回构造的AST节点。</p>
</div>
<div class="compound">
<p class="compound-first">这里有几处很有意思，其中最显著的便是该函数的行为，它不仅消化了所有与当前生成规则相关的所有语元，还把下一个待解析的语元放进了词法分析器的语元缓冲（该语元与当前的生成规则无关）。这是非常标准的递归下降解析器的行为。下面这个括号运算符的例子更能说明问题：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// parenexpr ::= &#39;(&#39; expression &#39;)&#39;</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseParenExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat (.</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">V</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">V</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;expected &#39;)&#39;&quot;</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat ).</span>
  <span class="k">return</span> <span class="n">V</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">该函数体现了这个语法解析器的几个特点：</p>
<ol class="compound-last arabic simple">
<li>它展示了<tt class="docutils literal"><span class="pre">Error</span></tt>函数的用法。调用该函数时，待解析的语元只能是“<tt class="docutils literal"><span class="pre">(</span></tt>”，然而解析完子表达式之后，紧跟着的语元却不一定是“<tt class="docutils literal"><span class="pre">)</span></tt>”。比如，要是用户输入的是“<tt class="docutils literal"><span class="pre">(4</span> <span class="pre">x</span></tt>”而不是“<tt class="docutils literal"><span class="pre">(4)</span></tt>”，语法解析器就应该报错。既然错误时有发生，语法解析器就必须提供一条报告错误的途径：就这个语法解析器而言，应对之道就是返回<tt class="docutils literal"><span class="pre">NULL</span></tt>。</li>
<li>该函数的另一特点在于递归调用了<tt class="docutils literal"><span class="pre">ParseExpression</span></tt>（很快我们就会看到<tt class="docutils literal"><span class="pre">ParseExpression</span></tt>还会反过来调用<tt class="docutils literal"><span class="pre">ParseParenExpr</span></tt>）。这种手法简化了递归语法的处理，每一条生成规则的实现都得以变得非常简洁。需要注意的是，我们没有必要为括号构造AST节点。虽然这么做也没错，但括号的作用主要还是对表达式进行分组进而引导语法解析过程。当语法解析器构造完AST之后，括号就没用了。</li>
</ol>
</div>
<div class="compound">
<p class="compound-first">下一条生成规则也很简单，它负责处理变量引用和函数调用：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// identifierexpr</span>
<span class="c1">///   ::= identifier</span>
<span class="c1">///   ::= identifier &#39;(&#39; expression* &#39;)&#39;</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseIdentifierExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>

  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat identifier.</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span> <span class="c1">// Simple variable ref.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">VariableExprAST</span><span class="p">(</span><span class="n">IdName</span><span class="p">);</span>

  <span class="c1">// Call.</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat (</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="n">Args</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Arg</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Arg</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">Args</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Arg</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;Expected &#39;)&#39; or &#39;,&#39; in argument list&quot;</span><span class="p">);</span>
      <span class="n">getNextToken</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">该函数与其它函数的风格别无二致。（调用该函数时当前语元必须是<tt class="docutils literal"><span class="pre">tok_identifier</span></tt>。）前文提到的有关递归和错误处理的特点它统统具备。有意思的是这里采用了<strong>预读</strong>（lookahead）的手段来试探当前标识符的类型，判断它究竟是个独立的变量引用还是个函数调用。只要检查紧跟标识符之后的语元是不是“<tt class="docutils literal"><span class="pre">(</span></tt>”，它就能知道到底应该构造<tt class="docutils literal"><span class="pre">VariableExprAST</span></tt>节点还是<tt class="docutils literal"><span class="pre">CallExprAST</span></tt>节点。</p>
</div>
<div class="compound">
<p class="compound-first">现在，解析各种表达式的代码都已经完成，不妨再添加一个辅助函数，为它们梳理一个统一的入口。我们将上述表达式称为<strong>主</strong>表达式（primary expression），具体原因参见本教程的<a class="reference internal" href="chapter-6.html#user-defined-unary-operators"><em>后续章节</em></a>。在解析各种主表达式时，我们首先要判定待解析表达式的类别：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// primary</span>
<span class="c1">///   ::= identifierexpr</span>
<span class="c1">///   ::= numberexpr</span>
<span class="c1">///   ::= parenexpr</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParsePrimary</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;unknown token when expecting an expression&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="nl">tok_identifier:</span> <span class="k">return</span> <span class="n">ParseIdentifierExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="nl">tok_number:</span>     <span class="k">return</span> <span class="n">ParseNumberExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>            <span class="k">return</span> <span class="n">ParseParenExpr</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">看完这个函数的定义，你就能明白为什么先前的各个函数能够放心大胆地对<tt class="docutils literal"><span class="pre">CurTok</span></tt>的取值作出假设了。这里预读了下一个语元，预先对待解析表达式的类型作出了判断，然后才调用相应的函数进行解析。</p>
</div>
<p>基本表达式全都搞定了，下面开始开始着手解析更为复杂的二元表达式。</p>
</div>
<div class="section" id="id9">
<h2>解析二元表达式<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>二元表达式的解析难度要大得多，因为它们往往具有二义性。例如，给定字符串“<tt class="docutils literal"><span class="pre">x+y*z</span></tt>”，语法解析器既可以将之解析为“<tt class="docutils literal"><span class="pre">(x+y)*z</span></tt>”，也可以将之解析为“<tt class="docutils literal"><span class="pre">x+(y*z)</span></tt>”。按照通常的数学定义，我们期望解析成后者，因为“<tt class="docutils literal"><span class="pre">*</span></tt>”（乘法）的优先级要高于“<tt class="docutils literal"><span class="pre">+</span></tt>”（加法）。</p>
<div class="compound">
<p class="compound-first">这个问题的解法很多，其中属<a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser">运算符优先级解析</a>最为优雅和高效。这是一种利用二元运算符的优先级来引导递归调用走向的解析技术。首先，我们需要制定一张优先级表：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// BinopPrecedence - This holds the precedence for each binary operator that is</span>
<span class="c1">/// defined.</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">BinopPrecedence</span><span class="p">;</span>

<span class="c1">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">GetTokPrecedence</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isascii</span><span class="p">(</span><span class="n">CurTok</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="c1">// Make sure it&#39;s a declared binop.</span>
  <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">BinopPrecedence</span><span class="p">[</span><span class="n">CurTok</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">TokPrec</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Install standard binary operators.</span>
  <span class="c1">// 1 is lowest precedence.</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;&lt;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;+&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;-&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;*&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>  <span class="c1">// highest.</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">最基本的Kaleidoscope语言仅支持4种二元运算符（对于我们英勇无畏的读者来说，再加几个运算符自然是小菜一碟）。函数<tt class="docutils literal"><span class="pre">GetTokPrecedence</span></tt>用于查询当前语元的优先级，如果当前语元不是二元运算符则返回<tt class="docutils literal"><span class="pre">-1</span></tt>。这里的<tt class="docutils literal"><span class="pre">map</span></tt>简化了新运算符的添加，同时也可以证明我们的算法与具体的运算符无关。当然，要想去掉<tt class="docutils literal"><span class="pre">map</span></tt>直接在<tt class="docutils literal"><span class="pre">GetTokPrecedence</span></tt>中比较优先级也很简单。（甚至可以直接使用定长数组）。</p>
</div>
<p>有了上面的函数作为辅助，我们就可以开始解析二元表达式了。运算符优先级解析的基本思想就是通过拆解含有二元运算符的表达式来解决可能的二义性问题。以表达式“<tt class="docutils literal"><span class="pre">a+b+(c+d)*e*f+g</span></tt>”为例，在进行运算符优先级解析时，它将被视作一串按二元运算符分隔的主表达式。按照这个思路，解析出来的第一个主表达式应该是“<tt class="docutils literal"><span class="pre">a</span></tt>”，紧跟着是若干个有序对，即：<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">b]</span></tt>、<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">(c+d)]</span></tt>、<tt class="docutils literal"><span class="pre">[*,</span> <span class="pre">e]</span></tt>、<tt class="docutils literal"><span class="pre">[*,</span> <span class="pre">f]</span></tt>和<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">g]</span></tt>。注意，括号表达式也是主表达式，所以在解析二元表达式时无须特殊照顾<tt class="docutils literal"><span class="pre">(c+d)</span></tt>这样的嵌套表达式。</p>
<div class="compound">
<p class="compound-first">一开始，每个表达式都由一个主表达式打头阵，身后可能还跟着一串由有序对构成的列表，其中有序对的格式为<tt class="docutils literal"><span class="pre">[binop,</span> <span class="pre">primaryexpr]</span></tt>：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// expression</span>
<span class="c1">///   ::= primary binoprhs</span>
<span class="c1">///</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span> <span class="o">=</span> <span class="n">ParsePrimary</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LHS</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">LHS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">函数<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>用于解析有序对列表（其中<tt class="docutils literal"><span class="pre">RHS</span></tt>是Right Hand Side的缩写，表示“右侧”；与此相对应，<tt class="docutils literal"><span class="pre">LHS</span></tt>表示“左侧”——译者注）。它的参数包括一个整数和一个指针，其中整数代表运算符优先级，指针则指向当前已解析出来的那部分表达式。注意，单独一个“<tt class="docutils literal"><span class="pre">x</span></tt>”也是合法的表达式：也就是说<tt class="docutils literal"><span class="pre">binoprhs</span></tt>有可能为空；碰到这种情况时，函数将直接返回作为参数传入的表达式。在上面的例子中，传入<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>的表达式是“<tt class="docutils literal"><span class="pre">a</span></tt>”，当前语元是“<tt class="docutils literal"><span class="pre">+</span></tt>”。</p>
</div>
<div class="compound">
<p class="compound-first">传入<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>的优先级表示的是该函数所能处理的<strong>最低运算符优先级</strong>。假设语元流中的下一对是“<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">x]</span></tt>”，且传入<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>的优先级是<tt class="docutils literal"><span class="pre">40</span></tt>，那么该函数将直接返回（因为“<tt class="docutils literal"><span class="pre">+</span></tt>”的优先级是<tt class="docutils literal"><span class="pre">20</span></tt>）。搞清楚这一点之后，我们再来看<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>的定义，函数的开头是这样的：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// binoprhs</span>
<span class="c1">///   ::= (&#39;+&#39; primary)*</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="kt">int</span> <span class="n">ExprPrec</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// If this is a binop, find its precedence.</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>

    <span class="c1">// If this is a binop that binds at least as tightly as the current binop,</span>
    <span class="c1">// consume it, otherwise we are done.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">ExprPrec</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">LHS</span><span class="p">;</span>
</pre></div>
</div>
<p class="compound-middle">这段代码首先检查当前语元的优先级，如果优先级过低就直接返回。由于无效语元（这里指不是二元运算符的语元——译者注）的优先级都被判作<tt class="docutils literal"><span class="pre">-1</span></tt>，因此当语元流中的所有二元运算符都被处理完毕时，该检查自然不会通过。如果检查通过，则可知当前语元一定是二元运算符，应该被纳入当前表达式：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre>    <span class="c1">// Okay, we know this is a binop.</span>
    <span class="kt">int</span> <span class="n">BinOp</span> <span class="o">=</span> <span class="n">CurTok</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat binop</span>

    <span class="c1">// Parse the primary expression after the binary operator.</span>
    <span class="n">ExprAST</span> <span class="o">*</span><span class="n">RHS</span> <span class="o">=</span> <span class="n">ParsePrimary</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RHS</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p class="compound-last">就这样，二元运算符处理完毕（并保存妥当）之后，紧跟其后的主表达式也随之解析完毕。至此，本例中的第一对有序对<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">b]</span></tt>就构造完了。</p>
</div>
<div class="compound">
<p class="compound-first">现在表达式的左侧和<tt class="docutils literal"><span class="pre">RHS</span></tt>序列中第一对都已经解析完毕，该考虑表达式的结合次序了。路有两条，要么选择“<tt class="docutils literal"><span class="pre">(a+b)</span> <span class="pre">binop</span> <span class="pre">unparsed</span></tt>”，要么选择“<tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">binop</span> <span class="pre">unparsed)</span></tt>”。为了搞清楚到底该怎么走，我们先预读出“<tt class="docutils literal"><span class="pre">binop</span></tt>”，查出它的优先级，再将之与<tt class="docutils literal"><span class="pre">BinOp</span></tt>（本例中是“<tt class="docutils literal"><span class="pre">+</span></tt>”）的优先级相比较：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre>    <span class="c1">// If BinOp binds less tightly with RHS than the operator after RHS, let</span>
    <span class="c1">// the pending operator take RHS as its LHS.</span>
    <span class="kt">int</span> <span class="n">NextPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">NextPrec</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p class="compound-middle"><tt class="docutils literal"><span class="pre">binop</span></tt>位于“<tt class="docutils literal"><span class="pre">RHS</span></tt>”的右侧，如果<tt class="docutils literal"><span class="pre">binop</span></tt>的优先级低于或等于当前运算符的优先级，则可知括号应该加在前面，即按“<tt class="docutils literal"><span class="pre">(a+b)</span> <span class="pre">binop</span> <span class="pre">...</span></tt>”处理。在本例中，当前运算符是“<tt class="docutils literal"><span class="pre">+</span></tt>”，下一个运算符也是“<tt class="docutils literal"><span class="pre">+</span></tt>”，二者的优先级相同。既然如此，理应按照“<tt class="docutils literal"><span class="pre">a+b</span></tt>”来构造AST节点，然后我们继续解析：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre>      <span class="c1">// ... if body omitted ...</span>
    <span class="p">}</span>

    <span class="c1">// Merge LHS/RHS.</span>
    <span class="n">LHS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryExprAST</span><span class="p">(</span><span class="n">BinOp</span><span class="p">,</span> <span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
  <span class="p">}</span>  <span class="c1">// loop around to the top of the while loop.</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">接着上面的例子，“<tt class="docutils literal"><span class="pre">a+b+</span></tt>”的前半段被解析成了“<tt class="docutils literal"><span class="pre">(a+b)</span></tt>”，于是“<tt class="docutils literal"><span class="pre">+</span></tt>”成为当前语元，进入下一轮迭代。上述代码进而将“<tt class="docutils literal"><span class="pre">(c+d)</span></tt>”识别为主表达式，并构造出相应的有序对<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">(c+d)]</span></tt>。现在，主表达式右侧的<tt class="docutils literal"><span class="pre">binop</span></tt>是“<tt class="docutils literal"><span class="pre">*</span></tt>”，由于“<tt class="docutils literal"><span class="pre">*</span></tt>”的优先级高于“<tt class="docutils literal"><span class="pre">+</span></tt>”，负责检查运算符优先级的<tt class="docutils literal"><span class="pre">if</span></tt>判断通过，执行流程得以进入<tt class="docutils literal"><span class="pre">if</span></tt>语句的内部。</p>
</div>
<div class="compound">
<p class="compound-first">现在关键问题来了：<tt class="docutils literal"><span class="pre">if</span></tt>语句内的代码怎样才能完整解析出表达式的右半部分呢？尤其是，为了构造出正确的AST，变量<tt class="docutils literal"><span class="pre">RHS</span></tt>必须完整表达“<tt class="docutils literal"><span class="pre">(c+d)*e*f</span></tt>”。出人意料的是，写成代码之后，这个问题出奇地简单：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre>    <span class="c1">// If BinOp binds less tightly with RHS than the operator after RHS, let</span>
    <span class="c1">// the pending operator take RHS as its LHS.</span>
    <span class="kt">int</span> <span class="n">NextPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">NextPrec</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">      <span class="n">RHS</span> <span class="o">=</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">TokPrec</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
</span><span class="hll">      <span class="k">if</span> <span class="p">(</span><span class="n">RHS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span>    <span class="p">}</span>

    <span class="c1">// Merge LHS/RHS.</span>
    <span class="n">LHS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryExprAST</span><span class="p">(</span><span class="n">BinOp</span><span class="p">,</span> <span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">看一下主表达式右侧的二元运算符，我们发现它的优先级比当前正在解析的<tt class="docutils literal"><span class="pre">binop</span></tt>的优先级要高。由此可知，如果自<tt class="docutils literal"><span class="pre">binop</span></tt>以右的若干个连续有序对都含有优先级高于“<tt class="docutils literal"><span class="pre">+</span></tt>”的运算符，那么就应该把它们全部解析出来，拼成“<tt class="docutils literal"><span class="pre">RHS</span></tt>”后返回。为此，我们将最低优先级设为“<tt class="docutils literal"><span class="pre">TokPrec+1</span></tt>”，递归调用函数“<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>”。该调用会完整解析出上述示例中的“<tt class="docutils literal"><span class="pre">(c+d)*e*f</span></tt>”，并返回构造出的AST节点，这个节点就是“<tt class="docutils literal"><span class="pre">+</span></tt>”表达式右侧的<tt class="docutils literal"><span class="pre">RHS</span></tt>。</p>
</div>
<p>最后，<tt class="docutils literal"><span class="pre">while</span></tt>循环的下一轮迭代将会解析出剩下的“<tt class="docutils literal"><span class="pre">+g</span></tt>”并将之纳入AST。仅需区区14行代码，我们就完整而优雅地实现了通用的二元表达式解析算法。上述讲解比较简略，这段代码还是颇有些难度的。我建议你找些棘手的例子多跑跑看，好彻底搞明白这段代码背后的原理。</p>
<p>表达式的解析就此告一段落。现在，我们可以将任意语元流喂入语法解析器并逐步从中构造出表达式，直到解析至不属于表达式的语元为止。接下来，我们来处理函数定义等其他结构。</p>
</div>
<div class="section" id="id11">
<h2>解析其余结构<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">下面来解析函数原型。在Kaleidoscope语言中，有两处会用到函数原型：一是“<tt class="docutils literal"><span class="pre">extern</span></tt>”函数声明，二是函数定义。相关代码很简单，没太大意思（相对于解析表达式的代码而言）：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// prototype</span>
<span class="c1">///   ::= id &#39;(&#39; id* &#39;)&#39;</span>
<span class="k">static</span> <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ParsePrototype</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected function name in prototype&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">FnName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected &#39;(&#39; in prototype&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ArgNames</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">getNextToken</span><span class="p">()</span> <span class="o">==</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="n">ArgNames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">IdentifierStr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected &#39;)&#39; in prototype&quot;</span><span class="p">);</span>

  <span class="c1">// success.</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat &#39;)&#39;.</span>

  <span class="k">return</span> <span class="k">new</span> <span class="n">PrototypeAST</span><span class="p">(</span><span class="n">FnName</span><span class="p">,</span> <span class="n">ArgNames</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">在此基础之上，函数定义就很简单了，说白了就是一个函数原型再加一个用作函数体的表达式：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// definition ::= &#39;def&#39; prototype expression</span>
<span class="k">static</span> <span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ParseDefinition</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat def.</span>
  <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span> <span class="o">=</span> <span class="n">ParsePrototype</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Proto</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FunctionAST</span><span class="p">(</span><span class="n">Proto</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">除了用于用户自定义函数的前置声明，“<tt class="docutils literal"><span class="pre">extern</span></tt>”语句还可以用来声明“<tt class="docutils literal"><span class="pre">sin</span></tt>”、“<tt class="docutils literal"><span class="pre">cos</span></tt>”等（C标准库）函数。这些“<tt class="docutils literal"><span class="pre">extern</span></tt>”语句不过就是些不带函数体的函数原型罢了：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// external ::= &#39;extern&#39; prototype</span>
<span class="k">static</span> <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ParseExtern</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat extern.</span>
  <span class="k">return</span> <span class="n">ParsePrototype</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">最后，我们还允许用户随时在顶层输入任意表达式并求值。这一特性是通过一个特殊的匿名零元函数（没有任何参数的函数）实现的，所有顶层表达式都定义在这个函数之内：</p>
<div class="compound-last highlight-cpp"><div class="highlight"><pre><span class="c1">/// toplevelexpr ::= expression</span>
<span class="k">static</span> <span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ParseTopLevelExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Make an anonymous proto.</span>
    <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrototypeAST</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FunctionAST</span><span class="p">(</span><span class="n">Proto</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>现在所有零部件都准备完毕了，只需再编写一小段引导代码就可以跑起来了！</p>
</div>
<div class="section" id="id12">
<h2>引导代码<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">引导代码很简单，只需在最外层的循环中按当前语元的类型选定相应的解析函数就可以了。这段实在没什么可介绍的，我就单独把最外层循环贴出来好了。完整代码<a class="reference internal" href="#chapter-2-full-code"><em>参见下方</em></a>“Top-Level Parsing”那一段。</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// top ::= definition | external | expression | &#39;;&#39;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">MainLoop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ready&gt; &quot;</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">tok_eof:</span>    <span class="k">return</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;;&#39;</span><span class="o">:</span>        <span class="n">getNextToken</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// ignore top-level semicolons.</span>
    <span class="k">case</span> <span class="nl">tok_def:</span>    <span class="n">HandleDefinition</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">tok_extern:</span> <span class="n">HandleExtern</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>         <span class="n">HandleTopLevelExpression</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">这段代码最有意思的地方在于我们忽略了顶层的分号。为什么呢？举个例子，当你在命令行中键入“<tt class="docutils literal"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">5</span></tt>”后，语法解析器无法判断你键入的内容是否已经完结。如果下一行键入的是“<tt class="docutils literal"><span class="pre">def</span> <span class="pre">foo...</span></tt>”，则可知顶层表达式就到<tt class="docutils literal"><span class="pre">4+5</span></tt>为止；但你也有可能会接着前面的表达式继续输入“<tt class="docutils literal"><span class="pre">*</span> <span class="pre">6</span></tt>”。有了顶层的分号，你就可以输入“<tt class="docutils literal"><span class="pre">4+5;</span></tt>”，于是语法解析器就能够辨别表达式在何处结束了。</p>
</div>
</div>
<div class="section" id="id13">
<h2>总结<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">算上注释我们一共只编写了不到400行代码（去掉注释和空行后只有240行），就完整地实现了包括词法分析器、语法解析器及AST生成器在内的最基本的Kaleidoscope语言。由此编译出的可执行文件用于校验Kaleidoscope代码在语法方面的正确性。请看下面这个例子：</p>
<div class="compound-middle highlight-python"><pre>$ ./a.out
ready&gt; def foo(x y) x+foo(y, 4.0);
Parsed a function definition.
ready&gt; def foo(x y) x+y y;
Parsed a function definition.
Parsed a top-level expr
ready&gt; def foo(x y) x+y );
Parsed a function definition.
Error: unknown token when expecting an expression
ready&gt; extern sin(a);
ready&gt; Parsed an extern
ready&gt; ^D
$</pre>
</div>
<p class="compound-last">可扩展的地方还有很多。通过定义新的AST节点，你可以按各种方式对语言进行扩展。在<a class="reference internal" href="chapter-3.html"><em>下一章</em></a>中，我们将介绍如何利通过AST生成LLVM中间语言（IR，Intermediate Representation）。</p>
</div>
</div>
<div class="section" id="chapter-2-full-code">
<span id="id14"></span><h2>完整源码<a class="headerlink" href="#chapter-2-full-code" title="永久链接至标题">¶</a></h2>
<p>以下是与本章和上一章内容相对应的完整代码。注意这段代码是独立的：无需链接LLVM或其他库即可编译运行。（当然，C和C++标准库除外。）编译方法如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c"># Compile</span>
clang++ -g -O3 toy.cpp
<span class="c"># Run</span>
./a.out
</pre></div>
</div>
<p>代码如下：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;cstdio&gt;</span>
<span class="cp">#include &lt;cstdlib&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;map&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Lexer</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span>
<span class="c1">// of these for known things.</span>
<span class="k">enum</span> <span class="n">Token</span> <span class="p">{</span>
  <span class="n">tok_eof</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>

  <span class="c1">// commands</span>
  <span class="n">tok_def</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">tok_extern</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>

  <span class="c1">// primary</span>
  <span class="n">tok_identifier</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">tok_number</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdentifierStr</span><span class="p">;</span>  <span class="c1">// Filled in if tok_identifier</span>
<span class="k">static</span> <span class="kt">double</span> <span class="n">NumVal</span><span class="p">;</span>              <span class="c1">// Filled in if tok_number</span>

<span class="c1">/// gettok - Return the next token from standard input.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gettok</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">LastChar</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

  <span class="c1">// Skip any whitespace.</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">LastChar</span><span class="p">))</span>
    <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">LastChar</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// identifier: [a-zA-Z][a-zA-Z0-9]*</span>
    <span class="n">IdentifierStr</span> <span class="o">=</span> <span class="n">LastChar</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">isalnum</span><span class="p">((</span><span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())))</span>
      <span class="n">IdentifierStr</span> <span class="o">+=</span> <span class="n">LastChar</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">&quot;def&quot;</span><span class="p">)</span> <span class="k">return</span> <span class="n">tok_def</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">&quot;extern&quot;</span><span class="p">)</span> <span class="k">return</span> <span class="n">tok_extern</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tok_identifier</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">LastChar</span><span class="p">)</span> <span class="o">||</span> <span class="n">LastChar</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// Number: [0-9.]+</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">NumStr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">NumStr</span> <span class="o">+=</span> <span class="n">LastChar</span><span class="p">;</span>
      <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">LastChar</span><span class="p">)</span> <span class="o">||</span> <span class="n">LastChar</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>

    <span class="n">NumVal</span> <span class="o">=</span> <span class="n">strtod</span><span class="p">(</span><span class="n">NumStr</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tok_number</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Comment until end of line.</span>
    <span class="k">do</span> <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">!=</span> <span class="n">EOF</span> <span class="o">&amp;&amp;</span> <span class="n">LastChar</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">LastChar</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">gettok</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Check for end of file.  Don&#39;t eat the EOF.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tok_eof</span><span class="p">;</span>

  <span class="c1">// Otherwise, just return the character as its ascii value.</span>
  <span class="kt">int</span> <span class="n">ThisChar</span> <span class="o">=</span> <span class="n">LastChar</span><span class="p">;</span>
  <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">ThisChar</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Abstract Syntax Tree (aka Parse Tree)</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// ExprAST - Base class for all expression nodes.</span>
<span class="k">class</span> <span class="nc">ExprAST</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ExprAST</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class="k">class</span> <span class="nc">NumberExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">Val</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">NumberExprAST</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">Val</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class="k">class</span> <span class="nc">VariableExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">VariableExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// BinaryExprAST - Expression class for a binary operator.</span>
<span class="k">class</span> <span class="nc">BinaryExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">Op</span><span class="p">;</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span><span class="p">,</span> <span class="o">*</span><span class="n">RHS</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">BinaryExprAST</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Op</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">LHS</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">RHS</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// CallExprAST - Expression class for function calls.</span>
<span class="k">class</span> <span class="nc">CallExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Callee</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="n">Args</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">CallExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">callee</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Callee</span><span class="p">(</span><span class="n">callee</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,</span>
<span class="c1">/// which captures its name, and its argument names (thus implicitly the number</span>
<span class="c1">/// of arguments the function takes).</span>
<span class="k">class</span> <span class="nc">PrototypeAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Args</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">PrototypeAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{}</span>

<span class="p">};</span>

<span class="c1">/// FunctionAST - This class represents a function definition itself.</span>
<span class="k">class</span> <span class="nc">FunctionAST</span> <span class="p">{</span>
  <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span><span class="p">;</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Body</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">FunctionAST</span><span class="p">(</span><span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">proto</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">body</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Proto</span><span class="p">(</span><span class="n">proto</span><span class="p">),</span> <span class="n">Body</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="p">{}</span>

<span class="p">};</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Parser</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span>
<span class="c1">/// token the parser is looking at.  getNextToken reads another token from the</span>
<span class="c1">/// lexer and updates CurTok with its results.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">CurTok</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">getNextToken</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">CurTok</span> <span class="o">=</span> <span class="n">gettok</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// BinopPrecedence - This holds the precedence for each binary operator that is</span>
<span class="c1">/// defined.</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">BinopPrecedence</span><span class="p">;</span>

<span class="c1">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">GetTokPrecedence</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isascii</span><span class="p">(</span><span class="n">CurTok</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="c1">// Make sure it&#39;s a declared binop.</span>
  <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">BinopPrecedence</span><span class="p">[</span><span class="n">CurTok</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">TokPrec</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Error* - These are little helper functions for error handling.</span>
<span class="n">ExprAST</span> <span class="o">*</span><span class="n">Error</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Str</span><span class="p">);</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
<span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ErrorP</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">Error</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ErrorF</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">Error</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseExpression</span><span class="p">();</span>

<span class="c1">/// identifierexpr</span>
<span class="c1">///   ::= identifier</span>
<span class="c1">///   ::= identifier &#39;(&#39; expression* &#39;)&#39;</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseIdentifierExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>

  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat identifier.</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span> <span class="c1">// Simple variable ref.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">VariableExprAST</span><span class="p">(</span><span class="n">IdName</span><span class="p">);</span>

  <span class="c1">// Call.</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat (</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="n">Args</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Arg</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Arg</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">Args</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Arg</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;Expected &#39;)&#39; or &#39;,&#39; in argument list&quot;</span><span class="p">);</span>
      <span class="n">getNextToken</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Eat the &#39;)&#39;.</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">new</span> <span class="n">CallExprAST</span><span class="p">(</span><span class="n">IdName</span><span class="p">,</span> <span class="n">Args</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// numberexpr ::= number</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseNumberExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NumberExprAST</span><span class="p">(</span><span class="n">NumVal</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// consume the number</span>
  <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// parenexpr ::= &#39;(&#39; expression &#39;)&#39;</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseParenExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat (.</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">V</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">V</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;expected &#39;)&#39;&quot;</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat ).</span>
  <span class="k">return</span> <span class="n">V</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// primary</span>
<span class="c1">///   ::= identifierexpr</span>
<span class="c1">///   ::= numberexpr</span>
<span class="c1">///   ::= parenexpr</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParsePrimary</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;unknown token when expecting an expression&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="nl">tok_identifier:</span> <span class="k">return</span> <span class="n">ParseIdentifierExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="nl">tok_number:</span>     <span class="k">return</span> <span class="n">ParseNumberExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>            <span class="k">return</span> <span class="n">ParseParenExpr</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// binoprhs</span>
<span class="c1">///   ::= (&#39;+&#39; primary)*</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="kt">int</span> <span class="n">ExprPrec</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// If this is a binop, find its precedence.</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>

    <span class="c1">// If this is a binop that binds at least as tightly as the current binop,</span>
    <span class="c1">// consume it, otherwise we are done.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">ExprPrec</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">LHS</span><span class="p">;</span>

    <span class="c1">// Okay, we know this is a binop.</span>
    <span class="kt">int</span> <span class="n">BinOp</span> <span class="o">=</span> <span class="n">CurTok</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat binop</span>

    <span class="c1">// Parse the primary expression after the binary operator.</span>
    <span class="n">ExprAST</span> <span class="o">*</span><span class="n">RHS</span> <span class="o">=</span> <span class="n">ParsePrimary</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RHS</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// If BinOp binds less tightly with RHS than the operator after RHS, let</span>
    <span class="c1">// the pending operator take RHS as its LHS.</span>
    <span class="kt">int</span> <span class="n">NextPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">NextPrec</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">RHS</span> <span class="o">=</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">TokPrec</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">RHS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Merge LHS/RHS.</span>
    <span class="n">LHS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryExprAST</span><span class="p">(</span><span class="n">BinOp</span><span class="p">,</span> <span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// expression</span>
<span class="c1">///   ::= primary binoprhs</span>
<span class="c1">///</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span> <span class="o">=</span> <span class="n">ParsePrimary</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LHS</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">LHS</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// prototype</span>
<span class="c1">///   ::= id &#39;(&#39; id* &#39;)&#39;</span>
<span class="k">static</span> <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ParsePrototype</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected function name in prototype&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">FnName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected &#39;(&#39; in prototype&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ArgNames</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">getNextToken</span><span class="p">()</span> <span class="o">==</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="n">ArgNames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">IdentifierStr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected &#39;)&#39; in prototype&quot;</span><span class="p">);</span>

  <span class="c1">// success.</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat &#39;)&#39;.</span>

  <span class="k">return</span> <span class="k">new</span> <span class="n">PrototypeAST</span><span class="p">(</span><span class="n">FnName</span><span class="p">,</span> <span class="n">ArgNames</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// definition ::= &#39;def&#39; prototype expression</span>
<span class="k">static</span> <span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ParseDefinition</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat def.</span>
  <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span> <span class="o">=</span> <span class="n">ParsePrototype</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Proto</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FunctionAST</span><span class="p">(</span><span class="n">Proto</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// toplevelexpr ::= expression</span>
<span class="k">static</span> <span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ParseTopLevelExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Make an anonymous proto.</span>
    <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrototypeAST</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FunctionAST</span><span class="p">(</span><span class="n">Proto</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// external ::= &#39;extern&#39; prototype</span>
<span class="k">static</span> <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ParseExtern</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat extern.</span>
  <span class="k">return</span> <span class="n">ParsePrototype</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Top-Level parsing</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">HandleDefinition</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ParseDefinition</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Parsed a function definition.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.</span>
    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">HandleExtern</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ParseExtern</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Parsed an extern</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.</span>
    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">HandleTopLevelExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Evaluate a top-level expression into an anonymous function.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ParseTopLevelExpr</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Parsed a top-level expr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.</span>
    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// top ::= definition | external | expression | &#39;;&#39;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">MainLoop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ready&gt; &quot;</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">tok_eof:</span>    <span class="k">return</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;;&#39;</span><span class="o">:</span>        <span class="n">getNextToken</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// ignore top-level semicolons.</span>
    <span class="k">case</span> <span class="nl">tok_def:</span>    <span class="n">HandleDefinition</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">tok_extern:</span> <span class="n">HandleExtern</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>         <span class="n">HandleTopLevelExpression</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Main driver code.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Install standard binary operators.</span>
  <span class="c1">// 1 is lowest precedence.</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;&lt;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;+&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;-&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;*&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>  <span class="c1">// highest.</span>

  <span class="c1">// Prime the first token.</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ready&gt; &quot;</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="c1">// Run the main &quot;interpreter loop&quot; now.</span>
  <span class="n">MainLoop</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div></div>
              </article><div class="clearer"></div>
          </div><div class="span3">
                <div class="sphinxsidebar">
      <div class="sphinxsidebarwrapper"><p class="logo">
              <a href="index.html">
                <img class="logo" src="_static/llvm-logo.png" alt="Logo"/>
              </a>
            </p><h4><a href="index.html">內容目录</a></h4>
  <ul>
<li><a class="reference internal" href="#">第二章 实现语法分析器和AST</a><ul>
<li><a class="reference internal" href="#id1">本章简介</a></li>
<li><a class="reference internal" href="#id6">抽象语法树（AST）</a></li>
<li><a class="reference internal" href="#id7">语法解析器基础</a></li>
<li><a class="reference internal" href="#id8">解析基本表达式</a></li>
<li><a class="reference internal" href="#id9">解析二元表达式</a></li>
<li><a class="reference internal" href="#id11">解析其余结构</a></li>
<li><a class="reference internal" href="#id12">引导代码</a></li>
<li><a class="reference internal" href="#id13">总结</a></li>
<li><a class="reference internal" href="#chapter-2-full-code">完整源码</a></li>
</ul>
</li>
</ul>
<h4>上一个主题</h4>
  <ul>
    <li>
      <a href="chapter-1.html" title="上一章">第一章 教程简介与词法分析器</a>
    </li>
  </ul><h4>下一个主题</h4>
  <ul>
    <li>
      <a href="chapter-3.html" title="下一章">第三章 LLVM IR代码生成</a>
    </li>
  </ul><h4>本页</h4>
  <ul>
    <li>
      <a href="_sources/chapter-2.txt" rel="nofollow">显示源代码</a>
    </li>
  </ul></div>
    </div>
              </div></div>
      </div><div class="footer container-fluid">
        <hr />&copy; 版权所有 2012, 连城.使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.</div></body>
</html>