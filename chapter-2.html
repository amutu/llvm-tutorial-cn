
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第二章 实现语法分析器和AST &mdash; LLVM教程</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="LLVM教程" href="index.html" />
    <link rel="next" title="第三章 LLVM IR代码生成" href="chapter-3.html" />
    <link rel="prev" title="第一章 教程简介与词法分析器" href="chapter-1.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="chapter-3.html" title="第三章 LLVM IR代码生成"
             accesskey="N">下一页</a></li>
        <li class="right" >
          <a href="chapter-1.html" title="第一章 教程简介与词法分析器"
             accesskey="P">上一页</a> |</li>
        <li><a href="index.html">LLVM教程</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ast">
<span id="chapter-2"></span><h1>第二章 实现语法分析器和AST<a class="headerlink" href="#ast" title="永久链接至标题">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">原文:</th><td class="field-body"><a class="reference external" href="http://llvm.org/docs/tutorial/LangImpl2.html">Implementing a Parser and AST</a></td>
</tr>
</tbody>
</table>
<div class="section" id="id1">
<h2>本章简介<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>欢迎进入“用LLVM开发新语言”教程的第二章。在本章中，我们将以第一章中开发的词法分析器为基础，为Kaleidoscope语言开发一个完整的<a class="reference external" href="http://en.wikipedia.org/wiki/Parsing">语法解析器</a>。等搞定了语法解析器，我们就开始定义并构造<a class="reference external" href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">抽象语法树</a>（AST，Abstract Syntax Tree）。</p>
<p>在解析Kaleidoscope的语法时，我们将综合运用<a class="reference external" href="http://en.wikipedia.org/wiki/Recursive_descent_parser">递归下降解析</a>和<a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser">运算符优先级解析</a>两种技术（后者用于解析二元表达式，前者用于其他部分）。在正式开始解析之前，不妨先来看一看解析器的输出：抽象语法树。</p>
</div>
<div class="section" id="id6">
<h2>抽象语法树（AST）<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">抽象语法树可以牢牢抓住程序行为的脉络，以便编译过程的后续环节（如代码生成）对程序进行解读。基本上，语言中的每种结构都需要一类对象与之相呼应，AST就是为语言量身定制的模型。Kaleidoscope的语法结构包括表达式、函数原型和函数对象。我们首先从表达式入手：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Abstract Syntax Tree (aka Parse Tree)</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// ExprAST - Base class for all expression nodes.</span>
<span class="k">class</span> <span class="nc">ExprAST</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ExprAST</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class="k">class</span> <span class="nc">NumberExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">Val</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">NumberExprAST</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">Val</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="compound-last">上述代码给出了基类<tt class="docutils literal"><span class="pre">ExprAST</span></tt>和一个用于表示数值常量的子类的定义。值得注意的是，子类<tt class="docutils literal"><span class="pre">NumberExprAST</span></tt>将常量的数值存入了成员变量，以便编译器在后续环节中获悉具体的数值。</p>
</div>
<div class="compound">
<p class="compound-first">截至目前为止，我们还只搭了AST的架子，尚未定义任何能够体现AST的实用价值的成员方法。例如，只需添加一套虚方法，我们就可以轻松实现代码的格式化打印。以下是Kaleidoscope语言最基本的部分所要用到的各种其他表达式的AST节点的定义：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class="k">class</span> <span class="nc">VariableExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">VariableExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// BinaryExprAST - Expression class for a binary operator.</span>
<span class="k">class</span> <span class="nc">BinaryExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">Op</span><span class="p">;</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span><span class="p">,</span> <span class="o">*</span><span class="n">RHS</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">BinaryExprAST</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Op</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">LHS</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">RHS</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// CallExprAST - Expression class for function calls.</span>
<span class="k">class</span> <span class="nc">CallExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Callee</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="n">Args</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">CallExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">callee</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Callee</span><span class="p">(</span><span class="n">callee</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="compound-last">我们（特意）将这几个类设计得十分简单明了：<tt class="docutils literal"><span class="pre">VariableExprAST</span></tt>用于保存变量名，<tt class="docutils literal"><span class="pre">BinaryExprAST</span></tt>用于保存运算符（如“<tt class="docutils literal"><span class="pre">+</span></tt>”），<tt class="docutils literal"><span class="pre">CallExprAST</span></tt>用于保存函数名和用作参数的表达式列表。这样设计AST有一个优势，那就是无须关注语法就可以直接抓住语言本身的特性。注意这里还没有涉及二元运算符的优先级和词法结构等问题。</p>
</div>
<div class="compound">
<p class="compound-first">仅用于描述语言中最基本的几个结构的话，定义好这几个表达式节点就够了。鉴于条件控制流程还没有实现，它还不算图灵完备；后面还会加以完善。接下来还有两件事，就是想办法描述函数的接口和函数本身：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,</span>
<span class="c1">/// which captures its name, and its argument names (thus implicitly the number</span>
<span class="c1">/// of arguments the function takes).</span>
<span class="k">class</span> <span class="nc">PrototypeAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Args</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">PrototypeAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{}</span>

<span class="p">};</span>

<span class="c1">/// FunctionAST - This class represents a function definition itself.</span>
<span class="k">class</span> <span class="nc">FunctionAST</span> <span class="p">{</span>
  <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span><span class="p">;</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Body</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">FunctionAST</span><span class="p">(</span><span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">proto</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">body</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Proto</span><span class="p">(</span><span class="n">proto</span><span class="p">),</span> <span class="n">Body</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="p">{}</span>

<span class="p">};</span>
</pre></div>
</div>
<p class="compound-last">在Kaleidoscope中，函数的类型是由参数的个数决定的。由于所有的值都是双精度浮点数，没有必要保存参数的类型。在功能更强大、更实用的语言中，<tt class="docutils literal"><span class="pre">ExprAST</span></tt>类很可能还会需要一个类型字段。</p>
</div>
<p>有了这些作为基础，我们就可以开始解析Kaleidoscope的表达式和函数体了。</p>
</div>
<div class="section" id="id7">
<h2>语法解析器基础<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">现在开始构造AST。首先，我们得准备好用于构造AST的语法解析器的代码。说白了，这里就是要利用语法解析器把“<tt class="docutils literal"><span class="pre">x+y</span></tt>“这样的输入（由词法分析器返回的三个语元）分解成由下列代码生成的AST：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="n">ExprAST</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VariableExprAST</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="n">ExprAST</span> <span class="o">*</span><span class="n">Y</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VariableExprAST</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">);</span>
<span class="n">ExprAST</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryExprAST</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
</pre></div>
</div>
<p class="compound-middle">为此，我们先定义几个辅助函数：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span>
<span class="c1">/// token the parser is looking at.  getNextToken reads another token from the</span>
<span class="c1">/// lexer and updates CurTok with its results.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">CurTok</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">getNextToken</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">CurTok</span> <span class="o">=</span> <span class="n">gettok</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">这段代码以词法分析器为中心，实现了一个简易的语元缓冲，让我们能够预先得知词法分析器将要返回的下一个语元。在我们的语法解析器中，所有函数都将<tt class="docutils literal"><span class="pre">CurTok</span></tt>视作当前待解析的语元。</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// Error* - These are little helper functions for error handling.</span>
<span class="n">ExprAST</span> <span class="o">*</span><span class="n">Error</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Str</span><span class="p">);</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
<span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ErrorP</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">Error</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ErrorF</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">Error</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">这三个<tt class="docutils literal"><span class="pre">Error</span></tt>系列的辅助函数也很简单，我们的语法解析器将用它们来处理解析过程中发生的错误。这里所采用的错误恢复策略绝非最佳方案，对用户也不怎么友好，不过对于这份教程而言倒也够用了。示例代码中各个函数的返回值类型各不相同，这几个函数简化了这些函数的错误处理：它们的返回值永远都是<tt class="docutils literal"><span class="pre">NULL</span></tt>。</p>
</div>
<p>准备好这几个辅助函数之后，我们开始实现第一条语法规则：数值常量。</p>
</div>
<div class="section" id="id8">
<h2>解析基本表达式<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">之所以先从数值常量下手，是因为它们最简单。针对Kaleidoscope语法中的每一条生成规则（production），我们都要定义一个与之对应的解析函数。对于数值常量，那就是：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// numberexpr ::= number</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseNumberExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NumberExprAST</span><span class="p">(</span><span class="n">NumVal</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// consume the number</span>
  <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">这个函数很简单：只有当待解析语元为<tt class="docutils literal"><span class="pre">tok_number</span></tt>时才能调用它。该函数首先用刚解析出的数值构造出一个<tt class="docutils literal"><span class="pre">NumberExprAST</span></tt>节点，然后令词法分析器继续读取下一个语元，最后返回。</p>
</div>
<div class="compound">
<p class="compound-first">这里有几处很有意思。首当其冲的便是该函数的行为，它不仅消化掉了所有与生成规则相关的所有语元，还又把下一个待解析的语元放进了词法分析器的语元缓冲（该语元与当前的生成规则无关）。这是非常标准的递归下降解析器的行为。下面这个括号运算符的例子更能说明问题：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// parenexpr ::= &#39;(&#39; expression &#39;)&#39;</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseParenExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat (.</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">V</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">V</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;expected &#39;)&#39;&quot;</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat ).</span>
  <span class="k">return</span> <span class="n">V</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">该函数体现了这个语法解析器的几个要点：</p>
<ol class="compound-last arabic simple">
<li>它展示了<tt class="docutils literal"><span class="pre">Error</span></tt>函数的用法。调用该函数时，待解析的语元应该是“<tt class="docutils literal"><span class="pre">(</span></tt>”，然而在子表达式解析完毕之后，紧跟着的语元却不一定是“<tt class="docutils literal"><span class="pre">)</span></tt>”。比如，要是用户输入的是“<tt class="docutils literal"><span class="pre">(4</span> <span class="pre">x</span></tt>”而不是“<tt class="docutils literal"><span class="pre">(4)</span></tt>”，语法解析器就应该报错。既然错误时有发生，语法解析器就需要一条报告错误的途径：就我们的语法解析器而言，只要发生错误，就返回<tt class="docutils literal"><span class="pre">NULL</span></tt>。</li>
<li>该函数的另一要点在于它递归调用了<tt class="docutils literal"><span class="pre">ParseExpression</span></tt>（很快我们就会看到<tt class="docutils literal"><span class="pre">ParseExpression</span></tt>还会反过来调用<tt class="docutils literal"><span class="pre">ParseParenExpr</span></tt>）。这一手法的长处在于递归语法的处理，它令每一条生成规则的实现都变得非常简单。需要注意的是，我们没有必要为括号构造AST节点。虽然这么做也没问题，但括号的作用主要还是对表达式进行分组并引导语法解析过程。当语法解析器构造完AST之后，括号就没用了。</li>
</ol>
</div>
<div class="compound">
<p class="compound-first">下一条生成规则也很简单，它负责处理变量引用和函数调用：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// identifierexpr</span>
<span class="c1">///   ::= identifier</span>
<span class="c1">///   ::= identifier &#39;(&#39; expression* &#39;)&#39;</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseIdentifierExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>

  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat identifier.</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span> <span class="c1">// Simple variable ref.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">VariableExprAST</span><span class="p">(</span><span class="n">IdName</span><span class="p">);</span>

  <span class="c1">// Call.</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat (</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="n">Args</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Arg</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Arg</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">Args</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Arg</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;Expected &#39;)&#39; or &#39;,&#39; in argument list&quot;</span><span class="p">);</span>
      <span class="n">getNextToken</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">该函数与其它函数的风格别无二致。（只有在当前语元为<tt class="docutils literal"><span class="pre">tok_identifier</span></tt>时才能调用它。）前文所述的递归和错误处理的特点它统统具备。有意思的是这里通过<strong>预读</strong>（lookahead）来试探当前标识符到底是独立的变量引用还是函数调用。它通过检查紧跟标识符之后的语元是不是“<tt class="docutils literal"><span class="pre">(</span></tt>”来决定到底应该构造<tt class="docutils literal"><span class="pre">VariableExprAST</span></tt>节点还是<tt class="docutils literal"><span class="pre">CallExprAST</span></tt>节点。</p>
</div>
<div class="compound">
<p class="compound-first">现在，解析各种表达式的代码都已经完成，不妨再写一个辅助函数，给它们添加一个统一的入口。我们将这类表达式称为<strong>主</strong>表达式（primary expression），具体原因参见本教程的<a class="reference internal" href="chapter-6.html#user-defined-unary-operators"><em>后续章节</em></a>。为了解析各种主表达式，我们首先要判定待解析表达式的类别：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// primary</span>
<span class="c1">///   ::= identifierexpr</span>
<span class="c1">///   ::= numberexpr</span>
<span class="c1">///   ::= parenexpr</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParsePrimary</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;unknown token when expecting an expression&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="nl">tok_identifier:</span> <span class="k">return</span> <span class="n">ParseIdentifierExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="nl">tok_number:</span>     <span class="k">return</span> <span class="n">ParseNumberExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>            <span class="k">return</span> <span class="n">ParseParenExpr</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">看到这个函数的定义之后，你就能明白为什么之前的各个函数能够放心大胆地对<tt class="docutils literal"><span class="pre">CurTok</span></tt>的取值作出假设了。这里预读了下一个语元，先对待解析表达式的种类作出了判断，然后才调用相应的函数进行解析。</p>
</div>
<p>基本表达式全部搞定，下面开始开始着手解决更为复杂的二元表达式。</p>
</div>
<div class="section" id="id9">
<h2>解析二元表达式<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>二元表达式的解析难度要大得多，因为它们往往具有二义性。例如，给定字符串“<tt class="docutils literal"><span class="pre">x+y*z</span></tt>”，语法解析器既可以将之解析为“<tt class="docutils literal"><span class="pre">(x+y)*z</span></tt>”，也可以将之解析为“<tt class="docutils literal"><span class="pre">x+(y*z)</span></tt>”。按照通常的数学定义，我们期望解析成后者，因为“<tt class="docutils literal"><span class="pre">*</span></tt>”（乘法）的优先级要高于“<tt class="docutils literal"><span class="pre">+</span></tt>”（加法）。</p>
<div class="compound">
<p class="compound-first">这个问题的处理方法有很多，其中属<a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser">运算符优先级解析</a>最为优雅、高效。这是一种利用二元运算符的优先级来引导递归调用走向的解析技术。首先，我们需要一张优先级表：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// BinopPrecedence - This holds the precedence for each binary operator that is</span>
<span class="c1">/// defined.</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">BinopPrecedence</span><span class="p">;</span>

<span class="c1">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">GetTokPrecedence</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isascii</span><span class="p">(</span><span class="n">CurTok</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="c1">// Make sure it&#39;s a declared binop.</span>
  <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">BinopPrecedence</span><span class="p">[</span><span class="n">CurTok</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">TokPrec</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Install standard binary operators.</span>
  <span class="c1">// 1 is lowest precedence.</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;&lt;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;+&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;-&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;*&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>  <span class="c1">// highest.</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">最基本的Kaleidoscope语言仅支持4种二元运算符（进一步的扩展对你来说一定不成问题，我们英勇无畏的读者）。<tt class="docutils literal"><span class="pre">GetTokPrecedence</span></tt>函数返回的是当前语元的优先级，若该语元不是二元运算符则返回<tt class="docutils literal"><span class="pre">-1</span></tt>。<tt class="docutils literal"><span class="pre">map</span></tt>的存在简化了新运算符的添加，同时也证明了我们的算法与具体的运算符无关。当然，要想去掉<tt class="docutils literal"><span class="pre">map</span></tt>直接在<tt class="docutils literal"><span class="pre">GetTokPrecedence</span></tt>中比较优先级也很简单。（甚至可以直接使用定长数组）。</p>
</div>
<p>有了上面的辅助函数，我们就可以开始解析二元表达式了。运算符优先级解析的基本思想，就是通过拆解含有二元运算符的表达式来解决可能的二义性问题。以表达式“<tt class="docutils literal"><span class="pre">a+b+(c+d)*e*f+g</span></tt>”为例，在进行运算符优先级解析时，它会被看作一串由二元运算符分隔的主表达式。也就是说，解析出来的第一个主表达式是“<tt class="docutils literal"><span class="pre">a</span></tt>”，然后是若干个语元对<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">b]</span></tt>、<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">(c+d)]</span></tt>、<tt class="docutils literal"><span class="pre">[*,</span> <span class="pre">e]</span></tt>、<tt class="docutils literal"><span class="pre">[*,</span> <span class="pre">f]</span></tt>和<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">g]</span></tt>。注意，括号表达式本身就是主表达式，所以在解析二元表达式时不用担心诸如<tt class="docutils literal"><span class="pre">(c+d)</span></tt>这种嵌套表达式。</p>
<div class="compound">
<p class="compound-first">好，现在开始。每个表达式都由一个主表达式打头阵，身后可能还跟着一个由语元对构成的列表，其中语元对的格式为<tt class="docutils literal"><span class="pre">[binop,</span> <span class="pre">primaryexpr]</span></tt>：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// expression</span>
<span class="c1">///   ::= primary binoprhs</span>
<span class="c1">///</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span> <span class="o">=</span> <span class="n">ParsePrimary</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LHS</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">LHS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last"><tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>是用来解析语元对列表的函数。它的参数包括一个代表运算符优先级的整数以及一个指向当前已解析出来的那部分表达式的指针。注意，“<tt class="docutils literal"><span class="pre">x</span></tt>”本身就是个完全合法的表达式：换言之，<tt class="docutils literal"><span class="pre">binoprhs</span></tt>可以为空，此时函数将直接返回作为参数传入的表达式。在上面的例子中，这段代码传给<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>的表达式是“<tt class="docutils literal"><span class="pre">a</span></tt>”，同时当前语元为“<tt class="docutils literal"><span class="pre">+</span></tt>”。</p>
</div>
<div class="compound">
<p class="compound-first">传入<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>的优先级表示的是该函数所能处理的<strong>最低运算符优先级</strong>。假设语元流中的下一个对为“<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">x]</span></tt>”，且传入<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>的优先级为<tt class="docutils literal"><span class="pre">40</span></tt>，那么该函数一个语元都不会碰（因为“<tt class="docutils literal"><span class="pre">+</span></tt>”的优先级是<tt class="docutils literal"><span class="pre">20</span></tt>）。搞清楚这一点之后，再来看看<tt class="docutils literal"><span class="pre">ParseBinOpRHS</span></tt>的定义，开头是这样的：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// binoprhs</span>
<span class="c1">///   ::= (&#39;+&#39; primary)*</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="kt">int</span> <span class="n">ExprPrec</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// If this is a binop, find its precedence.</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>

    <span class="c1">// If this is a binop that binds at least as tightly as the current binop,</span>
    <span class="c1">// consume it, otherwise we are done.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">ExprPrec</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">LHS</span><span class="p">;</span>
</pre></div>
</div>
<p class="compound-middle">这段代码检查了当前语元的优先级，优先级过低就直接返回。由于无效语元（这里指不是二元运算符的语元——译者注）的优先级被定义为<tt class="docutils literal"><span class="pre">-1</span></tt>，语元流中的二元运算符消耗殆尽的时候，我们自然能够发现。如果检查通过，我们就知道该语元一定是二元运算符，应该被纳入当前表达式：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre>    <span class="c1">// Okay, we know this is a binop.</span>
    <span class="kt">int</span> <span class="n">BinOp</span> <span class="o">=</span> <span class="n">CurTok</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat binop</span>

    <span class="c1">// Parse the primary expression after the binary operator.</span>
    <span class="n">ExprAST</span> <span class="o">*</span><span class="n">RHS</span> <span class="o">=</span> <span class="n">ParsePrimary</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RHS</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p class="compound-last">就这样，这段代码把这个二元运算符消化掉（并保存起来），然后继续解析紧随其后的主表达式。于是，整个语元对构造完毕；<tt class="docutils literal"><span class="pre">[+,</span> <span class="pre">b]</span></tt>是这个例子中的第一对。</p>
</div>
<div class="compound">
<p class="compound-first">现在，我们已经完成了表达式的左侧和<tt class="docutils literal"><span class="pre">RHS</span></tt>序列中第一对语元的解析， 该考虑表达式的结合次序了。我们有两种选择，要么解析成“<tt class="docutils literal"><span class="pre">(a+b)</span> <span class="pre">binop</span> <span class="pre">unparsed</span></tt>”，要么解析成“<tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">binop</span> <span class="pre">unparsed)</span></tt>”。为了作出定论，我们预读出“<tt class="docutils literal"><span class="pre">binop</span></tt>”，查出它的优先级，并与<tt class="docutils literal"><span class="pre">BinOp</span></tt>（本例中是“<tt class="docutils literal"><span class="pre">+</span></tt>”）的优先级相比较：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre>    <span class="c1">// If BinOp binds less tightly with RHS than the operator after RHS, let</span>
    <span class="c1">// the pending operator take RHS as its LHS.</span>
    <span class="kt">int</span> <span class="n">NextPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">NextPrec</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p class="compound-middle">如果“<tt class="docutils literal"><span class="pre">RHS</span></tt>”右侧的<tt class="docutils literal"><span class="pre">binop</span></tt>的优先级低于或等于当前运算符的优先级，我们就知道括号应该加在前面，即解析成“<tt class="docutils literal"><span class="pre">(a+b)</span> <span class="pre">binop</span> <span class="pre">...</span></tt>”。在本例中，当前运算符是“<tt class="docutils literal"><span class="pre">+</span></tt>”，下一个运算符也是“<tt class="docutils literal"><span class="pre">+</span></tt>”，二者的优先级相同。于是，我们构造一个表示“<tt class="docutils literal"><span class="pre">a+b</span></tt>”的AST节点，然后继续解析：</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre>      <span class="c1">// ... if body omitted ...</span>
    <span class="p">}</span>

    <span class="c1">// Merge LHS/RHS.</span>
    <span class="n">LHS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryExprAST</span><span class="p">(</span><span class="n">BinOp</span><span class="p">,</span> <span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
  <span class="p">}</span>  <span class="c1">// loop around to the top of the while loop.</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">In our example above, this will turn &#8220;a+b+&#8221; into &#8220;(a+b)&#8221; and execute the next iteration of the loop, with &#8220;+&#8221; as the current token. The code above will eat, remember, and parse &#8220;(c+d)&#8221; as the primary expression, which makes the current pair equal to [+, (c+d)]. It will then evaluate the &#8216;if&#8217; conditional above with &#8220;*&#8221; as the binop to the right of the primary. In this case, the precedence of &#8220;*&#8221; is higher than the precedence of &#8220;+&#8221; so the if condition will be entered.</p>
<p class="compound-last">接着在上面的例子，“<tt class="docutils literal"><span class="pre">a+b+</span></tt>”将被解析成“<tt class="docutils literal"><span class="pre">(a+b)</span></tt>”，然后“<tt class="docutils literal"><span class="pre">+</span></tt>”成为当前语元，开始下一轮迭代。上述代码将会读取“<tt class="docutils literal"><span class="pre">(c+d)</span></tt>”</p>
</div>
<div class="compound">
<p class="compound-first">The critical question left here is &#8220;how can the if condition parse the right hand side in full&#8221;? In particular, to build the AST correctly for our example, it needs to get all of &#8220;<tt class="docutils literal"><span class="pre">(c+d)*e*f</span></tt>&#8221; as the RHS expression variable. The code to do this is surprisingly simple (code from the above two blocks duplicated for context):</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre>    <span class="c1">// If BinOp binds less tightly with RHS than the operator after RHS, let</span>
    <span class="c1">// the pending operator take RHS as its LHS.</span>
    <span class="kt">int</span> <span class="n">NextPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">NextPrec</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">      <span class="n">RHS</span> <span class="o">=</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">TokPrec</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
</span><span class="hll">      <span class="k">if</span> <span class="p">(</span><span class="n">RHS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span>    <span class="p">}</span>

    <span class="c1">// Merge LHS/RHS.</span>
    <span class="n">LHS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryExprAST</span><span class="p">(</span><span class="n">BinOp</span><span class="p">,</span> <span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">At this point, we know that the binary operator to the RHS of our primary has higher precedence than the binop we are currently parsing. As such, we know that any sequence of pairs whose operators are all higher precedence than &#8220;+&#8221; should be parsed together and returned as &#8220;RHS&#8221;. To do this, we recursively invoke the ParseBinOpRHS function specifying &#8220;TokPrec+1&#8221; as the minimum precedence required for it to continue. In our example above, this will cause it to return the AST node for &#8220;(c+d)*e*f&#8221; as RHS, which is then set as the RHS of the &#8216;+&#8217; expression.</p>
</div>
<p>Finally, on the next iteration of the while loop, the &#8220;+g&#8221; piece is parsed and added to the AST. With this little bit of code (14 non-trivial lines), we correctly handle fully general binary expression parsing in a very elegant way. This was a whirlwind tour of this code, and it is somewhat subtle. I recommend running through it with a few tough examples to see how it works.</p>
<p>This wraps up handling of expressions. At this point, we can point the parser at an arbitrary token stream and build an expression from it, stopping at the first token that is not part of the expression. Next up we need to handle function definitions, etc.</p>
</div>
<div class="section" id="id11">
<h2>解析其余内容<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">The next thing missing is handling of function prototypes. In Kaleidoscope, these are used both for &#8216;extern&#8217; function declarations as well as function body definitions. The code to do this is straight-forward and not very interesting (once you&#8217;ve survived expressions):</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// prototype</span>
<span class="c1">///   ::= id &#39;(&#39; id* &#39;)&#39;</span>
<span class="k">static</span> <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ParsePrototype</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected function name in prototype&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">FnName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected &#39;(&#39; in prototype&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ArgNames</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">getNextToken</span><span class="p">()</span> <span class="o">==</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="n">ArgNames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">IdentifierStr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected &#39;)&#39; in prototype&quot;</span><span class="p">);</span>

  <span class="c1">// success.</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat &#39;)&#39;.</span>

  <span class="k">return</span> <span class="k">new</span> <span class="n">PrototypeAST</span><span class="p">(</span><span class="n">FnName</span><span class="p">,</span> <span class="n">ArgNames</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">Given this, a function definition is very simple, just a prototype plus an expression to implement the body:</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// definition ::= &#39;def&#39; prototype expression</span>
<span class="k">static</span> <span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ParseDefinition</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat def.</span>
  <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span> <span class="o">=</span> <span class="n">ParsePrototype</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Proto</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FunctionAST</span><span class="p">(</span><span class="n">Proto</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">In addition, we support &#8216;extern&#8217; to declare functions like &#8216;sin&#8217; and &#8216;cos&#8217; as well as to support forward declaration of user functions. These &#8216;extern&#8217;s are just prototypes with no body:</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// external ::= &#39;extern&#39; prototype</span>
<span class="k">static</span> <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ParseExtern</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat extern.</span>
  <span class="k">return</span> <span class="n">ParsePrototype</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-middle">Finally, we&#8217;ll also let the user type in arbitrary top-level expressions and evaluate them on the fly. We will handle this by defining anonymous nullary (zero argument) functions for them:</p>
<div class="compound-last highlight-cpp"><div class="highlight"><pre><span class="c1">/// toplevelexpr ::= expression</span>
<span class="k">static</span> <span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ParseTopLevelExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Make an anonymous proto.</span>
    <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrototypeAST</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FunctionAST</span><span class="p">(</span><span class="n">Proto</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Now that we have all the pieces, let&#8217;s build a little driver that will let us actually execute this code we&#8217;ve built!</p>
</div>
<div class="section" id="id12">
<h2>驱动代码<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">The driver for this simply invokes all of the parsing pieces with a top-level dispatch loop. There isn&#8217;t much interesting here, so I&#8217;ll just include the top-level loop. See <a class="reference internal" href="#chapter-2-full-code"><em>below</em></a> for full code in the &#8220;Top-Level Parsing&#8221; section.</p>
<div class="compound-middle highlight-cpp"><div class="highlight"><pre><span class="c1">/// top ::= definition | external | expression | &#39;;&#39;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">MainLoop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ready&gt; &quot;</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">tok_eof:</span>    <span class="k">return</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;;&#39;</span><span class="o">:</span>        <span class="n">getNextToken</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// ignore top-level semicolons.</span>
    <span class="k">case</span> <span class="nl">tok_def:</span>    <span class="n">HandleDefinition</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">tok_extern:</span> <span class="n">HandleExtern</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>         <span class="n">HandleTopLevelExpression</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="compound-last">The most interesting part of this is that we ignore top-level semicolons. Why is this, you ask? The basic reason is that if you type &#8220;4 + 5&#8221; at the command line, the parser doesn&#8217;t know whether that is the end of what you will type or not. For example, on the next line you could type &#8220;def foo...&#8221; in which case 4+5 is the end of a top-level expression. Alternatively you could type &#8220;* 6&#8221;, which would continue the expression. Having top-level semicolons allows you to type &#8220;4+5;&#8221;, and the parser will know you are done.</p>
</div>
</div>
<div class="section" id="id13">
<h2>结论<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="compound">
<p class="compound-first">With just under 400 lines of commented code (240 lines of non-comment, non-blank code), we fully defined our minimal language, including a lexer, parser, and AST builder. With this done, the executable will validate Kaleidoscope code and tell us if it is grammatically invalid. For example, here is a sample interaction:</p>
<div class="compound-middle highlight-python"><pre>$ ./a.out
ready&gt; def foo(x y) x+foo(y, 4.0);
Parsed a function definition.
ready&gt; def foo(x y) x+y y;
Parsed a function definition.
Parsed a top-level expr
ready&gt; def foo(x y) x+y );
Parsed a function definition.
Error: unknown token when expecting an expression
ready&gt; extern sin(a);
ready&gt; Parsed an extern
ready&gt; ^D
$</pre>
</div>
<p class="compound-last">There is a lot of room for extension here. You can define new AST nodes, extend the language in many ways, etc. In the <a class="reference internal" href="chapter-3.html"><em>next installment</em></a>, we will describe how to generate LLVM Intermediate Representation (IR) from the AST.</p>
</div>
</div>
<div class="section" id="chapter-2-full-code">
<span id="id14"></span><h2>完整源码<a class="headerlink" href="#chapter-2-full-code" title="永久链接至标题">¶</a></h2>
<p>Here is the complete code listing for this and the previous chapter. Note that it is fully self-contained: you don&#8217;t need LLVM or any external libraries at all for this. (Besides the C and C++ standard libraries, of course.) To build this, just compile with:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c"># Compile</span>
clang++ -g -O3 toy.cpp
<span class="c"># Run</span>
./a.out
</pre></div>
</div>
<p>Here is the code:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;cstdio&gt;</span>
<span class="cp">#include &lt;cstdlib&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;map&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Lexer</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span>
<span class="c1">// of these for known things.</span>
<span class="k">enum</span> <span class="n">Token</span> <span class="p">{</span>
  <span class="n">tok_eof</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>

  <span class="c1">// commands</span>
  <span class="n">tok_def</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">tok_extern</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>

  <span class="c1">// primary</span>
  <span class="n">tok_identifier</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">tok_number</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdentifierStr</span><span class="p">;</span>  <span class="c1">// Filled in if tok_identifier</span>
<span class="k">static</span> <span class="kt">double</span> <span class="n">NumVal</span><span class="p">;</span>              <span class="c1">// Filled in if tok_number</span>

<span class="c1">/// gettok - Return the next token from standard input.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gettok</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">LastChar</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

  <span class="c1">// Skip any whitespace.</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">LastChar</span><span class="p">))</span>
    <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">LastChar</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// identifier: [a-zA-Z][a-zA-Z0-9]*</span>
    <span class="n">IdentifierStr</span> <span class="o">=</span> <span class="n">LastChar</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">isalnum</span><span class="p">((</span><span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())))</span>
      <span class="n">IdentifierStr</span> <span class="o">+=</span> <span class="n">LastChar</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">&quot;def&quot;</span><span class="p">)</span> <span class="k">return</span> <span class="n">tok_def</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">&quot;extern&quot;</span><span class="p">)</span> <span class="k">return</span> <span class="n">tok_extern</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tok_identifier</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">LastChar</span><span class="p">)</span> <span class="o">||</span> <span class="n">LastChar</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// Number: [0-9.]+</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">NumStr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">NumStr</span> <span class="o">+=</span> <span class="n">LastChar</span><span class="p">;</span>
      <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">LastChar</span><span class="p">)</span> <span class="o">||</span> <span class="n">LastChar</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>

    <span class="n">NumVal</span> <span class="o">=</span> <span class="n">strtod</span><span class="p">(</span><span class="n">NumStr</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tok_number</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Comment until end of line.</span>
    <span class="k">do</span> <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">!=</span> <span class="n">EOF</span> <span class="o">&amp;&amp;</span> <span class="n">LastChar</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">LastChar</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">gettok</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Check for end of file.  Don&#39;t eat the EOF.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tok_eof</span><span class="p">;</span>

  <span class="c1">// Otherwise, just return the character as its ascii value.</span>
  <span class="kt">int</span> <span class="n">ThisChar</span> <span class="o">=</span> <span class="n">LastChar</span><span class="p">;</span>
  <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">ThisChar</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Abstract Syntax Tree (aka Parse Tree)</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// ExprAST - Base class for all expression nodes.</span>
<span class="k">class</span> <span class="nc">ExprAST</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ExprAST</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class="k">class</span> <span class="nc">NumberExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">Val</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">NumberExprAST</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">Val</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class="k">class</span> <span class="nc">VariableExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">VariableExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// BinaryExprAST - Expression class for a binary operator.</span>
<span class="k">class</span> <span class="nc">BinaryExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">Op</span><span class="p">;</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span><span class="p">,</span> <span class="o">*</span><span class="n">RHS</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">BinaryExprAST</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Op</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">LHS</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">RHS</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// CallExprAST - Expression class for function calls.</span>
<span class="k">class</span> <span class="nc">CallExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Callee</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="n">Args</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">CallExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">callee</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Callee</span><span class="p">(</span><span class="n">callee</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,</span>
<span class="c1">/// which captures its name, and its argument names (thus implicitly the number</span>
<span class="c1">/// of arguments the function takes).</span>
<span class="k">class</span> <span class="nc">PrototypeAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Args</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">PrototypeAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{}</span>

<span class="p">};</span>

<span class="c1">/// FunctionAST - This class represents a function definition itself.</span>
<span class="k">class</span> <span class="nc">FunctionAST</span> <span class="p">{</span>
  <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span><span class="p">;</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Body</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">FunctionAST</span><span class="p">(</span><span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">proto</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">body</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Proto</span><span class="p">(</span><span class="n">proto</span><span class="p">),</span> <span class="n">Body</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="p">{}</span>

<span class="p">};</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Parser</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span>
<span class="c1">/// token the parser is looking at.  getNextToken reads another token from the</span>
<span class="c1">/// lexer and updates CurTok with its results.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">CurTok</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">getNextToken</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">CurTok</span> <span class="o">=</span> <span class="n">gettok</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// BinopPrecedence - This holds the precedence for each binary operator that is</span>
<span class="c1">/// defined.</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">BinopPrecedence</span><span class="p">;</span>

<span class="c1">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">GetTokPrecedence</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isascii</span><span class="p">(</span><span class="n">CurTok</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="c1">// Make sure it&#39;s a declared binop.</span>
  <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">BinopPrecedence</span><span class="p">[</span><span class="n">CurTok</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">TokPrec</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Error* - These are little helper functions for error handling.</span>
<span class="n">ExprAST</span> <span class="o">*</span><span class="n">Error</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Str</span><span class="p">);</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
<span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ErrorP</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">Error</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ErrorF</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span> <span class="n">Error</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseExpression</span><span class="p">();</span>

<span class="c1">/// identifierexpr</span>
<span class="c1">///   ::= identifier</span>
<span class="c1">///   ::= identifier &#39;(&#39; expression* &#39;)&#39;</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseIdentifierExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>

  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat identifier.</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span> <span class="c1">// Simple variable ref.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">VariableExprAST</span><span class="p">(</span><span class="n">IdName</span><span class="p">);</span>

  <span class="c1">// Call.</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat (</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">*&gt;</span> <span class="n">Args</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Arg</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Arg</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">Args</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Arg</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;Expected &#39;)&#39; or &#39;,&#39; in argument list&quot;</span><span class="p">);</span>
      <span class="n">getNextToken</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Eat the &#39;)&#39;.</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">new</span> <span class="n">CallExprAST</span><span class="p">(</span><span class="n">IdName</span><span class="p">,</span> <span class="n">Args</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// numberexpr ::= number</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseNumberExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NumberExprAST</span><span class="p">(</span><span class="n">NumVal</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// consume the number</span>
  <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// parenexpr ::= &#39;(&#39; expression &#39;)&#39;</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseParenExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat (.</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">V</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">V</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;expected &#39;)&#39;&quot;</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat ).</span>
  <span class="k">return</span> <span class="n">V</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// primary</span>
<span class="c1">///   ::= identifierexpr</span>
<span class="c1">///   ::= numberexpr</span>
<span class="c1">///   ::= parenexpr</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParsePrimary</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;unknown token when expecting an expression&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="nl">tok_identifier:</span> <span class="k">return</span> <span class="n">ParseIdentifierExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="nl">tok_number:</span>     <span class="k">return</span> <span class="n">ParseNumberExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>            <span class="k">return</span> <span class="n">ParseParenExpr</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// binoprhs</span>
<span class="c1">///   ::= (&#39;+&#39; primary)*</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="kt">int</span> <span class="n">ExprPrec</span><span class="p">,</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// If this is a binop, find its precedence.</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>

    <span class="c1">// If this is a binop that binds at least as tightly as the current binop,</span>
    <span class="c1">// consume it, otherwise we are done.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">ExprPrec</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">LHS</span><span class="p">;</span>

    <span class="c1">// Okay, we know this is a binop.</span>
    <span class="kt">int</span> <span class="n">BinOp</span> <span class="o">=</span> <span class="n">CurTok</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat binop</span>

    <span class="c1">// Parse the primary expression after the binary operator.</span>
    <span class="n">ExprAST</span> <span class="o">*</span><span class="n">RHS</span> <span class="o">=</span> <span class="n">ParsePrimary</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RHS</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// If BinOp binds less tightly with RHS than the operator after RHS, let</span>
    <span class="c1">// the pending operator take RHS as its LHS.</span>
    <span class="kt">int</span> <span class="n">NextPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">NextPrec</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">RHS</span> <span class="o">=</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">TokPrec</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">RHS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Merge LHS/RHS.</span>
    <span class="n">LHS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryExprAST</span><span class="p">(</span><span class="n">BinOp</span><span class="p">,</span> <span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// expression</span>
<span class="c1">///   ::= primary binoprhs</span>
<span class="c1">///</span>
<span class="k">static</span> <span class="n">ExprAST</span> <span class="o">*</span><span class="n">ParseExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExprAST</span> <span class="o">*</span><span class="n">LHS</span> <span class="o">=</span> <span class="n">ParsePrimary</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LHS</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">LHS</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// prototype</span>
<span class="c1">///   ::= id &#39;(&#39; id* &#39;)&#39;</span>
<span class="k">static</span> <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ParsePrototype</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected function name in prototype&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">FnName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected &#39;(&#39; in prototype&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ArgNames</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">getNextToken</span><span class="p">()</span> <span class="o">==</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="n">ArgNames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">IdentifierStr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ErrorP</span><span class="p">(</span><span class="s">&quot;Expected &#39;)&#39; in prototype&quot;</span><span class="p">);</span>

  <span class="c1">// success.</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat &#39;)&#39;.</span>

  <span class="k">return</span> <span class="k">new</span> <span class="n">PrototypeAST</span><span class="p">(</span><span class="n">FnName</span><span class="p">,</span> <span class="n">ArgNames</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// definition ::= &#39;def&#39; prototype expression</span>
<span class="k">static</span> <span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ParseDefinition</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat def.</span>
  <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span> <span class="o">=</span> <span class="n">ParsePrototype</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Proto</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FunctionAST</span><span class="p">(</span><span class="n">Proto</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// toplevelexpr ::= expression</span>
<span class="k">static</span> <span class="n">FunctionAST</span> <span class="o">*</span><span class="n">ParseTopLevelExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Make an anonymous proto.</span>
    <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">Proto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrototypeAST</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FunctionAST</span><span class="p">(</span><span class="n">Proto</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// external ::= &#39;extern&#39; prototype</span>
<span class="k">static</span> <span class="n">PrototypeAST</span> <span class="o">*</span><span class="n">ParseExtern</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span>  <span class="c1">// eat extern.</span>
  <span class="k">return</span> <span class="n">ParsePrototype</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Top-Level parsing</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">HandleDefinition</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ParseDefinition</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Parsed a function definition.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.</span>
    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">HandleExtern</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ParseExtern</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Parsed an extern</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.</span>
    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">HandleTopLevelExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Evaluate a top-level expression into an anonymous function.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ParseTopLevelExpr</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Parsed a top-level expr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.</span>
    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// top ::= definition | external | expression | &#39;;&#39;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">MainLoop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ready&gt; &quot;</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">tok_eof:</span>    <span class="k">return</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;;&#39;</span><span class="o">:</span>        <span class="n">getNextToken</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// ignore top-level semicolons.</span>
    <span class="k">case</span> <span class="nl">tok_def:</span>    <span class="n">HandleDefinition</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">tok_extern:</span> <span class="n">HandleExtern</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>         <span class="n">HandleTopLevelExpression</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Main driver code.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Install standard binary operators.</span>
  <span class="c1">// 1 is lowest precedence.</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;&lt;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;+&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;-&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">&#39;*&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>  <span class="c1">// highest.</span>

  <span class="c1">// Prime the first token.</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ready&gt; &quot;</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="c1">// Run the main &quot;interpreter loop&quot; now.</span>
  <span class="n">MainLoop</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/llvm-logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">第二章 实现语法分析器和AST</a><ul>
<li><a class="reference internal" href="#id1">本章简介</a></li>
<li><a class="reference internal" href="#id6">抽象语法树（AST）</a></li>
<li><a class="reference internal" href="#id7">语法解析器基础</a></li>
<li><a class="reference internal" href="#id8">解析基本表达式</a></li>
<li><a class="reference internal" href="#id9">解析二元表达式</a></li>
<li><a class="reference internal" href="#id11">解析其余内容</a></li>
<li><a class="reference internal" href="#id12">驱动代码</a></li>
<li><a class="reference internal" href="#id13">结论</a></li>
<li><a class="reference internal" href="#chapter-2-full-code">完整源码</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="chapter-1.html"
                        title="上一章">第一章 教程简介与词法分析器</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="chapter-3.html"
                        title="下一章">第三章 LLVM IR代码生成</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chapter-2.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="搜索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的模块，术语，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="chapter-3.html" title="第三章 LLVM IR代码生成"
             >下一页</a></li>
        <li class="right" >
          <a href="chapter-1.html" title="第一章 教程简介与词法分析器"
             >上一页</a> |</li>
        <li><a href="index.html">LLVM教程</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; 版权所有 2012, 连城.
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>