**************************
第二章 实现语法分析器和AST
**************************

:原文: `Implementing a Parser and AST`__

__ http://llvm.org/docs/tutorial/LangImpl2.html

本章简介
========

欢迎进入“用LLVM开发新语言”教程的第二章。本章介绍的是如何利用第一章中开发的词法分析器来为我们的Kaleidoscope语言开发一个完整的\ `语法解析器`__\ 。语法解析器准备就绪之后，我们就能够定义并开始构造\ `抽象语法树`__\ （AST，Abstract Syntax Tree）了。

__ http://en.wikipedia.org/wiki/Parsing
__ http://en.wikipedia.org/wiki/Abstract_syntax_tree

为了解析Kaleidoscope语言的语法，我们将在语法解析器中综合运用\ `递归下降解析`__\ 和\ `运算符优先级解析`__\ 两种解析技术（后者用于解析二元表达式，前者用于其他部分）。在开始解析之前，让我们先来看一看解析器的输出：抽象语法树。

__ http://en.wikipedia.org/wiki/Recursive_descent_parser
__ http://en.wikipedia.org/wiki/Operator-precedence_parser

抽象语法树（AST）
=================

抽象语法树的作用在于抓住程序行为的要义，以便编译过程的后续环节（如代码生成）对程序进行解读。基本上，语言中的每种结构都需要一类对象与之相呼应，AST就是为语言量身定制的模型。Kaleidoscope的语法结构包括表达式、函数原型和函数对象。我们首先从表达式入手：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 72-89
    :language: cpp

上述代码给出了基类\ ``ExprAST``\ 和一个用于表示数值常量的子类的定义。值得注意的是，子类\ ``NumberExprAST``\ 将常量的数值存入了成员变量，以便编译器在后续环节中获悉具体的数值。

截至目前为止，我们还只搭了AST的架子，尚未定义任何能够体现AST的实用价值的成员方法。例如，只需添加一套虚方法，我们就可以轻松实现代码的格式化打印。以下是Kaleidoscope语言最基本的部分所要用到的各种其他表达式的AST节点的定义：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 91-114
    :language: cpp

我们（特意）将这几个类设计得十分简单明了：\ ``VariableExprAST``\ 用于保存变量名，\ ``BinaryExprAST``\ 用于保存运算符（如“\ ``+``\ ”），\ ``CallExprAST``\ 用于保存函数名和用作参数的表达式列表。这样设计AST有一个优势，那就是无须关注语法就可以直接抓住语言本身的特性。注意这里还没有涉及二元运算符的优先级和词法结构等问题。

仅用于描述语言中最基本的几个结构的话，定义好这几个表达式节点就够了。鉴于条件控制流程还没有实现，它还不算图灵完备；后面还会加以完善。接下来还有两件事，就是想办法描述函数的接口和函数本身：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 116-136
    :language: cpp

在Kaleidoscope中，函数的类型是由参数的个数决定的。由于所有的值都是双精度浮点数，没有必要保存参数的类型。在功能更强大、更实用的语言中，\ ``ExprAST``\ 类很可能还会需要一个类型字段。

有了这些作为基础，我们就可以开始解析Kaleidoscope的表达式和函数体。

语法解析器基础
==============

现在开始构造AST。首先，我们得准备好用于构造AST的语法解析器的代码。说白了，这里就是要利用语法解析器把“\ ``x+y``\ “这样的输入（由词法分析器返回的三个语元）分解成由下列代码生成的AST：

.. literalinclude:: _includes/chapter-2_sample-1.cpp
    :language: cpp

为此，我们先定义几个辅助函数：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 142-148
    :language: cpp

这段代码以词法分析器为中心，实现了一个简易的语元缓冲，让我们能够预先得知词法分析器将要返回的下一个语元。在我们的语法解析器中，所有函数都将\ ``CurTok``\ 视作当前待解析的语元。

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 165-168
    :language: cpp

这三个\ ``Error``\ 系列的辅助函数也很简单，我们的语法解析器将用它们来处理解析过程中发生的错误。这里所采用的错误恢复策略绝非最佳方案，对用户也不怎么友好，不过对于这份教程而言倒也够用了。示例代码中各个函数的返回值类型各不相同，这几个函数简化了这些函数的错误处理：它们的返回值永远都是\ ``NULL``\ 。

准备好这几个辅助函数之后，我们开始实现第一条语法规则：数值常量。

解析基本表达式
==============

之所以先从数值常量下手，就是因为它们最简单。针对语法中的每一条生成规则，我们都要定义一个与之对应的解析函数。与数值常量对应的函数就是：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 206-211
    :language: cpp

这个函数很简单：只有在待解析语元为\ ``tok_number``\ 时才能调用它。它用当前解析出的数值构造一个\ ``NumberExprAST``\ 节点，将词法分析器步进到下一个语元，最后返回。

这儿有几点很有趣。其中最重要的一点就是该函数会取走与该规则相关的所有语元并在返回前将下一个语元（该语元不属于当前的语法规则）放入语元缓冲。这是非常标准的递归下降解析器的行为。作为一个更合适的例子，括号运算符的定义如下：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 213-223
    :language: cpp

该函数展示了我们的解释器的几个有趣的地方：

#. 它展示了我们如何使用\ ``Error``\ 函数。该函数被调用时期望当前语元为“\ ``(``\ ”，但完成子表达式解析之后，后续的语元可能并不是“\ ``)``\ ”。例如，如果用户输入的是“\ ``( 4 x``\ ”而不是“\ ``(4)``\ ”，解析器就应该报错。由于可能发生错误，解析器需要一种用于标识发生了错误的方法：我们的解析器在碰到错误时会返回\ ``NULL``\ 。

#. 另一个有趣的地方在于，这个函数采用递归的方式调用了\ ``ParseExpression``\ （我们将看到\ ``ParseExpression``\ 会调用\ ``ParseParenExpr``\ a）。它的强大之处在于它使得我们得以处理递归的语法，并令规则非常简单明了。注意括号本身并不会引发AST节点的构造。虽然我们可以这样做，但括号最重要的作用还是在于引导解析器并对表达式进行分组。一旦解析器完成了AST的构造，括号就不再必要了。

下一个简单规则是用于处理变量引用和函数调用的：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 172-198
    :language: cpp

这段代码和其它函数的风格一致。（它应该在当前语元为\ ``tok_identifier``\ 时被调用）。它也具备递归和错误处理。比较有意思的时它采用了\ **预取**\ 的方式来确定当前的标识符到底是一个独立的变量引用还是一个函数调用表达式。它通过检查紧跟标识符之后的语元是否是“\ ``(``\ ”来决定应该构造一个\ ``VariableExprAST``\ 还是一个\ ``CallExprAST``\ 节点。

现在，所有的表达式解析逻辑都已经到位，我们可以写一个辅助函数将之包装到一个统一的入口。我们将这类表达式称为\ **主**\ 表达式，原因将在本教程的\ `后续章节`__\ 中详述。为了解析任意的主表达式，我们需要确定表达式的类型：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 225-236
    :language: cpp

__ http://llvm.org/docs/tutorial/LangImpl6.html#unary

现在你已经看到这个函数的定义，我们在各个函数中对\ ``CurTok``\ 值做假设的原因也就更明显了。这里用预取的方式来确定正要解析的表达式的种类，然后再调用相应的函数进行解析。

基本表达式都已经搞定了，得开始着手解决二元表达式了。它们要复杂一些。

解析二元表达式
==============

二元表达式要难解析得多，因为它们往往有二义性。例如，给定字符串“\ ``x+y*z``\ ”，解析器既可以将之解析为“\ ``(x+y)*z``\ ”，也可以将之解析为“\ ``x+(y*z)``\ ”。从通常的数学定义出发，我们期望按后者进行解析，因为“\ ``*``\ ”（乘法）的优先级要高于“\ ``+``\ ”（加法）。

处理这个问题的方法有很多种，但最优雅高效的方法还是使用\ `算符优先级解析`__\ 。这种解析技术利用二元运算符的优先级来引导递归。首先，我们需要一张优先级表：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 150-164,382-388
    :language: cpp
    :append:
          ...
        }

__ http://en.wikipedia.org/wiki/Operator-precedence_parser

就Kaleidoscope的基本形式而言，我们仅需支持4种二元运算符（作为我们英勇无畏的读者，您一定可以轻易对其进行扩展）。函数\ ``GetTokPrecedence``\ 返回当前语元的优先级，若该语元不是二元运算符则返回\ ``-1``\ 。借助\ ``map``\ 可以简化新运算符的添加，同时这种算法也不依赖于任何特定的运算符。不过要想省掉\ ``map``\ 并直接在\ ``GetTokPrecedence``\ 中进行优先级比较也很简单。（直接使用定长数组也行）。

借助上面定义的辅助函数，我们可以开始解析二元表达式了。算符优先级解析的基本思想是对包含可能具备二义性的二元运算符的表达式进行分解。以表达式“\ ``a+b+(c+d)*e*f+g``\ ”为例。算符优先级解析过程将之看作一串由二元运算符分隔的主表达式。如此一来，它首先解析出第一个主表达式“\ ``a``\ ”，然后陆续看到语元对\ ``[+, b]``\ 、\ ``[+, (c+d)]``\ 、\ ``[*, e]``\ 、\ ``[*, f]``\ 和\ ``[+, g]``\ 。注意，由于括号表达式是主表达式之一，处理二元表达式时完全不用担心\ ``(c+d)``\ 这样的嵌套表达式。

首先，表达式由一个主表达式开头，后续可能伴随着一个\ ``[binop, primaryexpr]``\ 序对的列表：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 271-279
    :language: cpp

``ParseBinOpRHS``\ 是为我们解析序对列表的函数。它携带着一个优先级和一个指向当前解析出的表达式的指针。注意“\ ``x``\ ”是一个完全合法的表达式：因此\ ``binoprhs``\ 可以为空，这时函数会将传入的表达式返回。在我们上面的例子中，这段代码会将“\ ``a``\ ”传入\ ``ParseBinOpRHS``\ ，同时当前语元为“\ ``+``\ ”。

传给\ ``ParseBinOpRHS``\ 的优先级代表了该函数所能消化的\ **最小运算符优先级**\ 。例如，若语元流中当前的序对为“\ ``[+, x]``\ ”且传给\ ``ParseBinOpRHS``\ 的优先级为40，则该函数不会再取走任何语元（因为“\ ``+``\ ”的优先级为20）。弄明白了这点，\ ``ParseBinOpRHS``\ 的定义可以像这样开始：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 238-248
    :language: cpp

这段代码查询当前语元的优先级并检查优先级是否过低。由于我们将非二元运算符语元的优先级定义为\ ``-1``\ ，因此该检查在序对流中不再有二元运算符时便会自行结束。如果检查通过，则该语元是一个二元运算符且会被囊括到当前的表达式中：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 250-256
    :language: cpp

解析其余内容
============

驱动代码
========

结论
====

.. _chapter-2_full-code:

完整源码
========

.. literalinclude:: _includes/chapter-2_full.cpp
    :language: cpp

.. vim:ft=rst ts=4 sw=4 et wrap
