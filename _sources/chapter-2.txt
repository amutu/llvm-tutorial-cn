**************************
第二章 实现语法分析器和AST
**************************

`本章原文`__

__ http://llvm.org/docs/tutorial/LangImpl2.html

第二章介绍
==========

欢迎来到“用LLVM开发新语言”教程的第二章。本章将介绍如何使用在第一章中打造的词法分析器来为我们的Kaleidoscope语言构建一个完整的\ `语法解析器`__\ 。准备好语法解析器后，我们便能够定义和构建\ `抽象语法树`__\ （AST，Abstract Syntax Tree）了。

__ http://en.wikipedia.org/wiki/Parsing
__ http://en.wikipedia.org/wiki/Abstract_syntax_tree

我们要打造的语法分析器将混合使用\ `递归下降解析法`__\ 和\ `算符优先级解析法`__\ 来解析Kaleidoscope语言（后者用于解析二元表达式而前者解析其余内容）。在开始解析工作之前，让我们先来讨论一下解析过程的输出：抽象语法树。

__ http://en.wikipedia.org/wiki/Recursive_descent_parser
__ http://en.wikipedia.org/wiki/Operator-precedence_parser

抽象语法树（AST）
=================

程序的抽象语法树的作用在于抓住程序行为的要义，以便编译器后续环节（如代码生成）对其进行解析。基本上，我们希望语言中的每个结构都有一个对象与之对应，AST也应该对语言进行紧密的建模。在Kaleidoscope中，我们有表达式、函数原型和函数对象。我们首先从表达式入手：

.. include:: include/chapter-2-code-1.rst

上述代码定义了基类\ ``ExprAST``\ 和一个用于数值常量的子类。需要注意的一点是，\ ``NumberExprAST``\ 将文本所表示的数值存放在了成员变量中。这样编译器的后续环节便可以得知所存的数值。

目前为止我们还只是构建了AST，尚无有用的访问它们的方法。比如，我们可以很容易地增加一个虚方法来对代码作格式化打印。一下我们将在Kaleidoscope中用到的其他表达式AST节点的定义：

.. include:: include/chapter-2-code-2.rst

这部分（有意地）设计得非常直截了当：\ ``VariableExprAST``\ 保存变量名，\ ``BinaryExprAST``\ 保存操作符（如“+”），\ ``CallExprAST``\ 保存函数名和作为参数的表达式列表。我们设计的AST的优势之一便是可以在不涉及语法的情况下抓住语言本身的特性。注意这里还没有讨论二元运算符的优先级和词法结构等等。

对我们的基本语言来说，这些就是需要定义的所有表达式节点了。由于目前还不具备条件控制流程，它还不是图灵完备的；我们将在后续环节中予以完善。接下来要做的两件事是找出一种描述函数接口的方法和一种描述函数自身的方法：

.. include:: include/chapter-2-code-3.rst

在Kaleidoscope中，函数的类型是由其参数个数决定的。由于所有的值都是双精度浮点数，无须存储参数本身的类型。在更强大和实际的语言中，\ ``ExprAST``\ 类就很可能会有一个类型字段。

有了这些作为脚手架，我们就可以开始讨论Kaleidoscope中表达式和函数体的语法解析了。

语法分析器基础
==============

现在我们要开始构造AST了，我们得定义完成构造工作的解析代码。其基本想法是将诸如“x+y”（在此处应是由词法分析器返回的三个标记）这样的东西借助这样的调用解析成AST：

.. include:: include/chapter-2-code-4.rst

为了达到这个目的，我们先定义一些辅助代码：

.. include:: include/chapter-2-code-5.rst

这段代码借助词法分析器实现了一个简单的标记缓冲，使得我们可以提前看到词法分析器将要返回的下一个标记。我们的语法解析器中的所有函数都假设\ ``CurTok``\ 是当前正需要解析的标记。

.. include:: include/chapter-2-code-6.rst

``Error``\ 函数是我们的解析器用来处理错误的一个简单的辅助函数。我们的解析器的错误恢复策略并不是最好的，对用户也不特别友好，不过对我们的教程而言也已经足够了。这几个函数简化了那些具备不同返回值类型的函数的错误处理：它们只返回\ ``NULL``\ 。

有了这些辅助函数，我们就可以开始实现第一份语法了：数值常量。

解析基本表达式
==============

之所以从数值常量开始，是因为针对它们的处理最简单。

解析二元表达式
==============

解析其余内容
============

驱动代码
========

结论
====

.. _chapter-2-code:

完整源码
========

.. include:: include/chapter-2-code-full.rst

.. vim:ft=rst ts=4 sw=4 fenc=utf-8 enc=utf-8 et wrap
