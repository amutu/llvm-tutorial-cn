.. _chapter-2:

**************************
第二章 实现语法分析器和AST
**************************

:原文: `Implementing a Parser and AST <http://llvm.org/docs/tutorial/LangImpl2.html>`_

本章简介
========

欢迎进入“用LLVM开发新语言”教程的第二章。在本章中，我们将以第一章中开发的词法分析器为基础，为Kaleidoscope语言开发一个完整的\ `语法解析器`__\ 。等搞定了语法解析器，我们就开始定义并构造\ `抽象语法树`__\ （AST，Abstract Syntax Tree）。

__ http://en.wikipedia.org/wiki/Parsing
__ http://en.wikipedia.org/wiki/Abstract_syntax_tree

在解析Kaleidoscope的语法时，我们将综合运用\ `递归下降解析`__\ 和\ `运算符优先级解析`__\ 两种技术（后者用于解析二元表达式，前者用于其他部分）。在正式开始解析之前，不妨先来看一看解析器的输出：抽象语法树。

__ http://en.wikipedia.org/wiki/Recursive_descent_parser
__ http://en.wikipedia.org/wiki/Operator-precedence_parser

抽象语法树（AST）
=================

.. compound::

    抽象语法树可以牢牢抓住程序行为的脉络，以便编译过程的后续环节（如代码生成）对程序进行解读。基本上，语言中的每种结构都需要一类对象与之相呼应，AST就是为语言量身定制的模型。Kaleidoscope的语法结构包括表达式、函数原型和函数对象。我们首先从表达式入手：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 74-89

    上述代码给出了基类\ ``ExprAST``\ 和一个用于表示数值常量的子类的定义。值得注意的是，子类\ ``NumberExprAST``\ 将常量的数值存入了成员变量，以便编译器在后续环节中获悉具体的数值。

.. compound::

    截至目前为止，我们还只搭了AST的架子，尚未定义任何能够体现AST的实用价值的成员方法。例如，只需添加一套虚方法，我们就可以轻松实现代码的格式化打印。以下是Kaleidoscope语言最基本的部分所要用到的各种其他表达式的AST节点的定义：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 91-114

    我们（特意）将这几个类设计得十分简单明了：\ ``VariableExprAST``\ 用于保存变量名，\ ``BinaryExprAST``\ 用于保存运算符（如“\ ``+``\ ”），\ ``CallExprAST``\ 用于保存函数名和用作参数的表达式列表。这样设计AST有一个优势，那就是无须关注语法就可以直接抓住语言本身的特性。注意这里还没有涉及二元运算符的优先级和词法结构等问题。

.. compound::

    仅用于描述语言中最基本的几个结构的话，定义好这几个表达式节点就够了。鉴于条件控制流程还没有实现，它还不算图灵完备；后面还会加以完善。接下来还有两件事，就是想办法描述函数的接口和函数本身：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 116-136

    在Kaleidoscope中，函数的类型是由参数的个数决定的。由于所有的值都是双精度浮点数，没有必要保存参数的类型。在功能更强大、更实用的语言中，\ ``ExprAST``\ 类很可能还会需要一个类型字段。

有了这些作为基础，我们就可以开始解析Kaleidoscope的表达式和函数体了。

语法解析器基础
==============

.. compound::

    现在开始构造AST。首先，我们得准备好用于构造AST的语法解析器的代码。说白了，这里就是要利用语法解析器把“\ ``x+y``\ “这样的输入（由词法分析器返回的三个语元）分解成由下列代码生成的AST：

    .. literalinclude:: _includes/chapter-2_sample-1.cpp
        :language: cpp

    为此，我们先定义几个辅助函数：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 142-148

    这段代码以词法分析器为中心，实现了一个简易的语元缓冲，让我们能够预先得知词法分析器将要返回的下一个语元。在我们的语法解析器中，所有函数都将\ ``CurTok``\ 视作当前待解析的语元。

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 165-168

    这三个\ ``Error``\ 系列的辅助函数也很简单，我们的语法解析器将用它们来处理解析过程中发生的错误。这里所采用的错误恢复策略绝非最佳方案，对用户也不怎么友好，不过对于这份教程而言倒也够用了。示例代码中各个函数的返回值类型各不相同，这几个函数简化了这些函数的错误处理：它们的返回值永远都是\ ``NULL``\ 。

准备好这几个辅助函数之后，我们开始实现第一条语法规则：数值常量。

解析基本表达式
==============

.. compound::

    之所以先从数值常量下手，是因为它们最简单。针对Kaleidoscope语法中的每一条生成规则（production），我们都要定义一个与之对应的解析函数。对于数值常量，那就是：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 206-211

    这个函数很简单：只有当待解析语元为\ ``tok_number``\ 时才能调用它。该函数首先用刚解析出的数值构造出一个\ ``NumberExprAST``\ 节点，然后令词法分析器继续读取下一个语元，最后返回。

.. compound::

    这里有几处很有意思。首当其冲的便是该函数的行为，它不仅消化掉了所有与生成规则相关的所有语元，还又把下一个待解析的语元放进了词法分析器的语元缓冲（该语元与当前的生成规则无关）。这是非常标准的递归下降解析器的行为。下面这个括号运算符的例子更能说明问题：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 213-223

    该函数体现了这个语法解析器的几个要点：

    #.  它展示了\ ``Error``\ 函数的用法。调用该函数时，待解析的语元应该是“\ ``(``\ ”，然而在子表达式解析完毕之后，紧跟着的语元却不一定是“\ ``)``\ ”。比如，要是用户输入的是“\ ``(4 x``\ ”而不是“\ ``(4)``\ ”，语法解析器就应该报错。既然错误时有发生，语法解析器就需要一条报告错误的途径：就我们的语法解析器而言，只要发生错误，就返回\ ``NULL``\ 。

    #.  该函数的另一要点在于它递归调用了\ ``ParseExpression``\ （很快我们就会看到\ ``ParseExpression``\ 还会反过来调用\ ``ParseParenExpr``\ ）。这一手法的长处在于递归语法的处理，它令每一条生成规则的实现都变得非常简单。需要注意的是，我们没有必要为括号构造AST节点。虽然这么做也没问题，但括号的作用主要还是对表达式进行分组并引导语法解析过程。当语法解析器构造完AST之后，括号就没用了。

.. compound::

    下一条生成规则也很简单，它负责处理变量引用和函数调用：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 172-198

    该函数与其它函数的风格别无二致。（只有在当前语元为\ ``tok_identifier``\ 时才能调用它。）前文所述的递归和错误处理的特点它统统具备。有意思的是这里通过\ **预读**\ （lookahead）来试探当前标识符到底是独立的变量引用还是函数调用。它通过检查紧跟标识符之后的语元是不是“\ ``(``\ ”来决定到底应该构造\ ``VariableExprAST``\ 节点还是\ ``CallExprAST``\ 节点。

.. compound::

    现在，解析各种表达式的代码都已经完成，不妨再写一个辅助函数，给它们添加一个统一的入口。我们将这类表达式称为\ **主**\ 表达式（primary expression），具体原因参见本教程的\ :ref:`后续章节 <user-defined-unary-operators>`\ 。为了解析各种主表达式，我们首先要判定待解析表达式的类别：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 225-236

    看到这个函数的定义之后，你就能明白为什么之前的各个函数能够放心大胆地对\ ``CurTok``\ 的取值作出假设了。这里预读了下一个语元，先对待解析表达式的种类作出了判断，然后才调用相应的函数进行解析。

基本表达式全部搞定，下面开始开始着手解决更为复杂的二元表达式。

解析二元表达式
==============

二元表达式的解析难度要大得多，因为它们往往具有二义性。例如，给定字符串“\ ``x+y*z``\ ”，语法解析器既可以将之解析为“\ ``(x+y)*z``\ ”，也可以将之解析为“\ ``x+(y*z)``\ ”。按照通常的数学定义，我们期望解析成后者，因为“\ ``*``\ ”（乘法）的优先级要高于“\ ``+``\ ”（加法）。

.. compound::

    这个问题的处理方法有很多，其中属\ `运算符优先级解析`__\ 最为优雅、高效。这是一种利用二元运算符的优先级来引导递归调用走向的解析技术。首先，我们需要一张优先级表：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 150-164,382-388
        :append:
              ...
            }

    最基本的Kaleidoscope语言仅支持4种二元运算符（进一步的扩展对你来说一定不成问题，我们英勇无畏的读者）。\ ``GetTokPrecedence``\ 函数返回的是当前语元的优先级，若该语元不是二元运算符则返回\ ``-1``\ 。\ ``map``\ 的存在简化了新运算符的添加，同时也证明了我们的算法与具体的运算符无关。当然，要想去掉\ ``map``\ 直接在\ ``GetTokPrecedence``\ 中比较优先级也很简单。（甚至可以直接使用定长数组）。

__ http://en.wikipedia.org/wiki/Operator-precedence_parser

有了上面的辅助函数，我们就可以开始解析二元表达式了。运算符优先级解析的基本思想，就是通过拆解含有二元运算符的表达式来解决可能的二义性问题。以表达式“\ ``a+b+(c+d)*e*f+g``\ ”为例，在进行运算符优先级解析时，它会被看作一串由二元运算符分隔的主表达式。也就是说，解析出来的第一个主表达式是“\ ``a``\ ”，然后是若干个语元对\ ``[+, b]``\ 、\ ``[+, (c+d)]``\ 、\ ``[*, e]``\ 、\ ``[*, f]``\ 和\ ``[+, g]``\ 。注意，括号表达式本身就是主表达式，所以在解析二元表达式时不用担心诸如\ ``(c+d)``\ 这种嵌套表达式。

.. compound::

    好，现在开始。每个表达式都由一个主表达式打头阵，身后可能还跟着一个由语元对构成的列表，其中语元对的格式为\ ``[binop, primaryexpr]``\ ：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 271-279

    ``ParseBinOpRHS``\ 是用来解析语元对列表的函数。它的参数包括一个代表运算符优先级的整数以及一个指向当前已解析出来的那部分表达式的指针。注意，“\ ``x``\ ”本身就是个完全合法的表达式：换言之，\ ``binoprhs``\ 可以为空，此时函数将直接返回作为参数传入的表达式。在上面的例子中，这段代码传给\ ``ParseBinOpRHS``\ 的表达式是“\ ``a``\ ”，同时当前语元为“\ ``+``\ ”。

.. compound::

    传入\ ``ParseBinOpRHS``\ 的优先级表示的是该函数所能处理的\ **最低运算符优先级**\ 。假设语元流中的下一个对为“\ ``[+, x]``\ ”，且传入\ ``ParseBinOpRHS``\ 的优先级为\ ``40``\ ，那么该函数一个语元都不会碰（因为“\ ``+``\ ”的优先级是\ ``20``\ ）。搞清楚这一点之后，再来看看\ ``ParseBinOpRHS``\ 的定义，开头是这样的：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 238-248

    这段代码检查了当前语元的优先级，优先级过低就直接返回。由于无效语元（这里指不是二元运算符的语元——译者注）的优先级被定义为\ ``-1``\ ，语元流中的二元运算符消耗殆尽的时候，我们自然能够发现。如果检查通过，我们就知道该语元一定是二元运算符，应该被纳入当前表达式：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 250-256

    就这样，这段代码把这个二元运算符消化掉（并保存起来），然后继续解析紧随其后的主表达式。于是，整个语元对构造完毕；\ ``[+, b]``\ 是这个例子中的第一对。

.. compound::

    现在，我们已经完成了表达式的左侧和\ ``RHS``\ 序列中第一对语元的解析， 该考虑表达式的结合次序了。我们有两种选择，要么解析成“\ ``(a+b) binop unparsed``\ ”，要么解析成“\ ``a + (b binop unparsed)``\ ”。为了作出定论，我们预读出“\ ``binop``\ ”，查出它的优先级，并与\ ``BinOp``\ （本例中是“\ ``+``\ ”）的优先级相比较：

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 258-261

    如果“\ ``RHS``\ ”右侧的\ ``binop``\ 的优先级低于或等于当前运算符的优先级，我们就知道括号应该加在前面，即解析成“\ ``(a+b) binop ...``\ ”。在本例中，当前运算符是“\ ``+``\ ”，下一个运算符也是“\ ``+``\ ”，二者的优先级相同。于是，我们构造一个表示“\ ``a+b``\ ”的AST节点，然后继续解析：

    .. code-block:: cpp

              // ... if body omitted ...
            }

            // Merge LHS/RHS.
            LHS = new BinaryExprAST(BinOp, LHS, RHS);
          }  // loop around to the top of the while loop.
        }

    In our example above, this will turn "a+b+" into "(a+b)" and execute the next iteration of the loop, with "+" as the current token. The code above will eat, remember, and parse "(c+d)" as the primary expression, which makes the current pair equal to [+, (c+d)]. It will then evaluate the 'if' conditional above with "*" as the binop to the right of the primary. In this case, the precedence of "*" is higher than the precedence of "+" so the if condition will be entered.

    接着在上面的例子，“\ ``a+b+``\ ”将被解析成“\ ``(a+b)``\ ”，然后“\ ``+``\ ”成为当前语元，开始下一轮迭代。上述代码将会读取“\ ``(c+d)``\ ”

.. compound::

    The critical question left here is "how can the if condition parse the right hand side in full"? In particular, to build the AST correctly for our example, it needs to get all of "``(c+d)*e*f``" as the RHS expression variable. The code to do this is surprisingly simple (code from the above two blocks duplicated for context):

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 258-269
        :emphasize-lines: 5-6

    At this point, we know that the binary operator to the RHS of our primary has higher precedence than the binop we are currently parsing. As such, we know that any sequence of pairs whose operators are all higher precedence than "+" should be parsed together and returned as "RHS". To do this, we recursively invoke the ParseBinOpRHS function specifying "TokPrec+1" as the minimum precedence required for it to continue. In our example above, this will cause it to return the AST node for "(c+d)*e*f" as RHS, which is then set as the RHS of the '+' expression.

Finally, on the next iteration of the while loop, the "+g" piece is parsed and added to the AST. With this little bit of code (14 non-trivial lines), we correctly handle fully general binary expression parsing in a very elegant way. This was a whirlwind tour of this code, and it is somewhat subtle. I recommend running through it with a few tough examples to see how it works.

This wraps up handling of expressions. At this point, we can point the parser at an arbitrary token stream and build an expression from it, stopping at the first token that is not part of the expression. Next up we need to handle function definitions, etc.

解析其余内容
============

.. compound::

    The next thing missing is handling of function prototypes. In Kaleidoscope, these are used both for 'extern' function declarations as well as function body definitions. The code to do this is straight-forward and not very interesting (once you've survived expressions):

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 281-303

    Given this, a function definition is very simple, just a prototype plus an expression to implement the body:

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 305-314

    In addition, we support 'extern' to declare functions like 'sin' and 'cos' as well as to support forward declaration of user functions. These 'extern's are just prototypes with no body:

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 326-330

    Finally, we'll also let the user type in arbitrary top-level expressions and evaluate them on the fly. We will handle this by defining anonymous nullary (zero argument) functions for them:

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 316-324

Now that we have all the pieces, let's build a little driver that will let us actually execute this code we've built!

驱动代码
========

.. compound::

    The driver for this simply invokes all of the parsing pieces with a top-level dispatch loop. There isn't much interesting here, so I'll just include the top-level loop. See :ref:`below <chapter-2_full-code>` for full code in the "Top-Level Parsing" section.

    .. literalinclude:: _includes/chapter-2_full.cpp
        :language: cpp
        :lines: 364-376

    The most interesting part of this is that we ignore top-level semicolons. Why is this, you ask? The basic reason is that if you type "4 + 5" at the command line, the parser doesn't know whether that is the end of what you will type or not. For example, on the next line you could type "def foo..." in which case 4+5 is the end of a top-level expression. Alternatively you could type "* 6", which would continue the expression. Having top-level semicolons allows you to type "4+5;", and the parser will know you are done.

结论
====

.. compound::

    With just under 400 lines of commented code (240 lines of non-comment, non-blank code), we fully defined our minimal language, including a lexer, parser, and AST builder. With this done, the executable will validate Kaleidoscope code and tell us if it is grammatically invalid. For example, here is a sample interaction:

    ::

        $ ./a.out
        ready> def foo(x y) x+foo(y, 4.0);
        Parsed a function definition.
        ready> def foo(x y) x+y y;
        Parsed a function definition.
        Parsed a top-level expr
        ready> def foo(x y) x+y );
        Parsed a function definition.
        Error: unknown token when expecting an expression
        ready> extern sin(a);
        ready> Parsed an extern
        ready> ^D
        $

    There is a lot of room for extension here. You can define new AST nodes, extend the language in many ways, etc. In the :doc:`next installment <chapter-3>`, we will describe how to generate LLVM Intermediate Representation (IR) from the AST.

.. _chapter-2_full-code:

完整源码
========

Here is the complete code listing for this and the previous chapter. Note that it is fully self-contained: you don't need LLVM or any external libraries at all for this. (Besides the C and C++ standard libraries, of course.) To build this, just compile with:

.. code-block:: bash

    # Compile
    clang++ -g -O3 toy.cpp
    # Run
    ./a.out

Here is the code:

.. literalinclude:: _includes/chapter-2_full.cpp
    :language: cpp

.. vim:ft=rst ts=4 sw=4 et wrap
