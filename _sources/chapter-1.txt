.. _chapter-1:

***************************
第一章 教程简介与词法分析器
***************************

:原文: `Tutorial Introduction and the Lexer <http://llvm.org/docs/tutorial/LangImpl1.html>`_

教程介绍
========

欢迎走进“用LLVM开发新语言”教程。本教程详细介绍了一门简单语言的实现过程；你将会看到，这个过程既轻松又有趣。本教程将伴你一起搭建一套框架，它可以成为你今后实现其他语言的基础。教程中的代码就是供你把玩LLVM的各种功能的试验田。

本教程的目标是循序渐进地描绘我们的语言，并详述它的构建过程。在这一过程中，我们将针对语言设计和LLVM的用法等很多问题进行讨论。与此同时，为了让你不至于被大量的细节弄得晕头转向，我们会给出相关代码并进行讲解。

需要提前说明的是，这一教程讲授的是编译器技术和LLVM，而\ **不是**\ 四平八稳的现代化软件工程准则。换言之，为了方便讲解，我们会采用一些不太正规的手法。比如，代码中存在内存泄漏、遍地是全局变量、无视\ `visitor`__\ 之类的成熟设计模式等等……一切从简。如果你有意深入研究，并把这些代码用作今后项目的基础，这些问题倒也不难修。

__ http://en.wikipedia.org/wiki/Visitor_pattern

我试着编排了本教程的各个章节，碰到熟悉的或是不感兴趣的章节，你大可直接跳过。本教程结构如下：

- :doc:`第一章 <chapter-1>`\ ：\ **Kaleidoscope语言及其词法解析器简介**\ ——说明我们的目的，以及新语言应该具备些什么基本功能。为了尽量让这份教程易于理解和入手，我们决定不采用任何词法分析器和语法分析器的生成器\ [#]_\ ，而是直接用C++实现所有功能。当然，配合这些工具使用LLVM也完全没问题，如果乐意，你大可一试。

- :doc:`第二章 <chapter-2>`\ ：\ **实现语法分析器和AST**\ ——完成了词法分析器，接下来就该讨论语法解析技术并开始构造基本的AST（Abstract Syntax Tree，抽象语法树——译者注）了。这份教程共介绍了递归下降解析和运算符优先级解析两种解析技术。\ :doc:`第一章 <chapter-1>`\ 和\ :doc:`第二章 <chapter-2>`\ 的内容与LLVM完全无关，至此我们的代码甚至都不需要链接LLVM库。 :-)

- :doc:`第三章 <chapter-3>`\ ：\ **LLVM IR代码生成**\ ——搞定AST之后，我们将炫耀一番，让你看看LLVM IR的生成过程是多么的简单。

- :doc:`第四章 <chapter-4>`\ ：\ **添加JIT和优化支持**\ ——鉴于很多人对如何把LLVM用作JIT感兴趣，我们打算在此深入一下，让你看看用于添加JIT支持的那三行代码。尽管LLVM在其他方面的用途也很广泛，但要说炫技，还是这三行代码最简单也最“惊艳”。

- :doc:`第五章 <chapter-5>`\ ：\ **语言扩展：流程控制**\ ——我们的语言已经准备就绪可以运行了，现在来看看如何给它添加流程控制能力（\ ``if``/``then``/``else``\ 和“\ ``for``\ ”循环）。在此我们还将借机介绍一下简单的\ `SSA`__\ 构造和流程控制。

- :doc:`第六章 <chapter-6>`\ ：\ **语言扩展：用户自定义运算符**\ ——这一章虽然无聊但却很有意思，它讨论了如何对语言进行扩展，从而让用户能够在程序中自行定义任意的一元和二元运算符（还可以设置优先级！）。这一机制使得我们得以将该“语言”的很大一部分都实现成库函数。

- :doc:`第七章 <chapter-7>`\ ：\ **语言扩展：可变变量**\ ——本章介绍的是如何添加用户自定义局部变量和赋值运算符。最有趣儿的地方在于，在LLVM中构造SSA form简单至极：不，实际上LLVM压根儿就\ **不**\ 要求你在前端\ [#]_\ 构造SSA form！

- :doc:`第八章 <chapter-8>`\ ：\ **结论以及其他和LLVM相关的内容**\ ——本章对整个系列教程进行了总结，不仅讨论了多种潜在的语言扩展方向，同时还给出了一系列“专题”的参考资料，例如垃圾回收支持、异常、调试、“\ `意面式栈`__\ ”支持，此外还有很多其他窍门和技巧。

__ http://en.wikipedia.org/wiki/Static_single_assignment_form
__ http://en.wikipedia.org/wiki/Spaghetti_stack

到本教程末尾为止，不算注释和空行，我们总共只需编写不到700行代码。面对这样一门相对复杂的语言，我们只用了这么点儿代码就实现了一个像样的编译器，包括手工打造的词法分析器、语法分析器、AST，还实现了带JIT编译器的代码生成。我想，相对于那些仅能给出“hello world”级别的教程的系统，这篇教程的广度足以诠释LLVM的强大；如果你对语言和编译器设计感兴趣，它应该能够说服你认真考虑考虑LLVM。

最后说一句：我们希望你能够对这一语言进行扩展，好好玩味一番。拿着代码疯狂地hack去吧，编译器并非令人恐惧的怪兽——把玩程序语言，奇乐无穷！

基础语言
========

本教程将采用一门玩具语言来进行讲解，这门语言名叫“\ `Kaleidoscope`__\ ”（引申为“美丽、形态万千、多姿多彩”）\ [#]_\ 。Kaleidoscope是一个过程式语言，利用它你可以定义函数、使用条件语句，还能进行数学运算等等。随着教程的深入，我们将逐步扩展Kaleidoscope，为它增加\ ``if``/``then``/``else``\ 结构、\ ``for``\ 循环、用户自定义运算符，以及带有简单命令行界面的JIT编译器等等。

__ http://en.wikipedia.org/wiki/Kaleidoscope

简单起见，Kaleidoscope只支持一种数据类型，即64位浮点数（也就是C中的“double”）。这样一来，所有的值都是双精度浮点数，类型申明也省了，语言的语法简洁明快。例如，以下是一个用于计算\ `斐波那契数`__\ 的简单示例：

.. literalinclude:: _includes/chapter-1_1.kaleido

__ http://en.wikipedia.org/wiki/Fibonacci_number

Kaleidoscope还能调用标准库函数（有了LLVM JIT，实现这一点简单至极）。不过，在调用函数之前需要先用“\ ``extern``\ ”关键字对函数进行申明\ [#]_\ （碰到相互递归调用的函数\ [#]_\ 时也需要这么做）。例如：

.. literalinclude:: _includes/chapter-1_2.kaleido

:doc:`第六章 <chapter-6>`\ 中有一个更有趣的例子：我们用Kaleidoscope编写了一个小应用，可以在不同尺度上\ `显示Mandelbrot集合`__\ 。

__ http://llvm.org/docs/tutorial/LangImpl6.html#example

让我们来细细品味一下这门语言的实现过程吧！

词法分析器
==========

要实现一门语言，第一要务就是对文本文件进行处理，搞明白其中写了些什么。传统上，我们采用“\ `词法分析器`__\ ”（也称为“扫描器”）将输入切成“语元（token）”。由词法分析器返回的每个语元都带有一个语元编号，此外可能还会附带一些元数据（例如某个数的数值）。首先，我们来定义所有可能出现的语元：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 6-24
    :language: cpp

__ http://en.wikipedia.org/wiki/Lexical_analysis

由我们的词法分析器返回的语元，要么是上述语元枚举值之一，要么是诸如“\ ``+``\ ”这样的“未知”字符。对于后一种情况，词法分析器将返回这些字符的ASCII值。若当前语元是个标识符，则标识符的名称将被存放于全局变量\ ``IdentifierStr``\ 之中。若当前语元是个数值常量（比如1.0），其值将被存放于\ ``NumVal``\ 中。注意，简单起见我们使用了全局变量，对于真正的语言实现而言这可不是最佳选择 :-) 。

Kaleidoscope的词法分析器由一个名为\ ``gettok``\ 的函数实现。\ ``gettok``\ 函数被调用时，会从标准输入中返回下一个语元。该函数的开头是这样的：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 27-32
    :language: cpp

``gettok``\ 通过C标准库的\ ``getchar()``\ 函数从标准输入中逐个读入字符。它一边读取和识别字符，一边将读入的最后一个字符存入\ ``LastChar``\ 中留待后续处理。该函数要做的第一件事就是借助上述循环剔除语元之间的空白符。

接下来，\ ``gettok``\ 要识别出标识符和诸如“\ ``def``\ ”等特定的关键字。Kaleidoscope通过下面这个简单循环来达到目的：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 34-42
    :language: cpp

注意，由这段代码识别出的标识符，会被立即存入全局变量\ ``IdentifierStr``\ 。此外，语言的关键字也由这个循环负责识别，在此处一并处理。数值的识别过程与此类似：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 44-53
    :language: cpp

处理输入的代码十分直截了当。在输入中碰到代表数值的字符串时，我们利用C标准库中的\ ``strtod``\ 函数将之转换为数值并存入\ ``NumVal``\ 。注意这里缺少充分的错误检测：这段代码会错误地将“1.23.45.67”识别成“1.23”。至于要不要改，那就随便你了 :-) 。下面我们来处理注释：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 55-62
    :language: cpp

注释的处理很简单：直接跳过注释行并返回下一个语元即可。最后，如果输入与上述所有情况都不相符，那么它要么是个代表运算符的字符（比如“\ ``+``\ “），要么就是已经一路读到文件末尾了。这两种情况由以下代码负责处理：

.. literalinclude:: _includes/chapter-2_full.cpp
    :lines: 64-72
    :language: cpp

至此，完整的Kaleidoscope词法分析器就完成了（\ :ref:`完整源码 <chapter-2_full-code>`\ 参见本教程的\ :doc:`下一章 <chapter-2>`\ ）。接下来，我们将\ :doc:`编写一个简单的语法分析器并利用它来构建抽象语法树 <chapter-2>`\ 。届时，我们还会再加上一段引导代码，令词法分析器和语法分析器珠联璧合。

.. rubric:: 脚注

.. [#] 例如lex/yacc或flex/bison——译者注。
.. [#] 这里指的是编译器或解释器的前端——译者注。
.. [#] Kaleidoscope意即“万花筒”——译者注。
.. [#] 原文中用的是define；但从上下文来看此处应该是函数原型声明，而非函数定义，故改译作“声明”——译者注。
.. [#] 指函数A调用函数B，函数B又反过来调用函数A，从而形成递归调用的情况——译者注。

.. vim:ft=rst ts=4 sw=4 et wrap
